WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.395
我们已经很了解一维卡尔曼滤波器了

00:00:03.395 --> 00:00:08.359
你编写了一个程序 了解如何利用测量值

00:00:08.359 --> 00:00:10.099
了解如何利用动作

00:00:10.099 --> 00:00:13.379
实现了非常酷的功能

00:00:13.380 --> 00:00:17.969
即完整的一维卡尔曼滤波器

00:00:17.969 --> 00:00:20.474
在现实中 通常有很多维度

00:00:20.475 --> 00:00:22.330
情况更复杂

00:00:22.329 --> 00:00:26.399
我通过一个示例来讲解下

00:00:26.399 --> 00:00:31.279
为何在更高维度的空间里估算很重要

00:00:31.280 --> 00:00:34.899
假设有个二维状态空间 x 和 y

00:00:34.899 --> 00:00:36.390
例如摄像头图像

00:00:36.390 --> 00:00:40.490
或者对我们来说 可能有一辆车使用雷达

00:00:40.490 --> 00:00:46.075
检测车辆随时间推移的位置

00:00:46.075 --> 00:00:50.810
二维卡尔曼滤波器可以得出很精彩的结果

00:00:50.810 --> 00:00:52.755
讲解一下

00:00:52.755 --> 00:00:56.015
假设在时间 t 为 0 时

00:00:56.015 --> 00:01:00.100
观察到目标对象的坐标在这里

00:01:00.100 --> 00:01:03.704
这可能是对 Google 无人驾驶汽车来说另一辆当前车辆

00:01:03.704 --> 00:01:07.295
一个时间步之后 看到它在这里

00:01:07.295 --> 00:01:10.609
再过一个时间步之后 看到它在这里

00:01:10.609 --> 00:01:16.885
当时间 t 等于 3 时 你预计该对象会在哪？

00:01:16.885 --> 00:01:19.960
我指定三个不同的位置

00:01:22.219 --> 00:01:24.804
答案是这里

00:01:24.805 --> 00:01:30.480
如果在更高维度的空间里进行估算

00:01:30.480 --> 00:01:34.079
卡尔曼滤波器不仅会进入 (x,y) 空间

00:01:34.079 --> 00:01:39.370
而且会隐含地得出对象的速度

00:01:39.370 --> 00:01:44.520
然后使用速度估计值很好地预测未来

00:01:44.519 --> 00:01:49.479
注意 传感器本身只能看到位置

00:01:49.480 --> 00:01:51.490
它始终无法看到实际速度

00:01:51.489 --> 00:01:54.519
速度是通过看到多个位置推断的

00:01:54.519 --> 00:01:58.089
卡尔曼滤波器在跟踪应用

00:01:58.090 --> 00:02:02.010
方面的一个精彩功能是

00:02:02.010 --> 00:02:04.130
能够得出对象的速度

00:02:04.129 --> 00:02:06.379
虽然从未直接测量速度

00:02:06.379 --> 00:02:09.004
然后能够根据速度

00:02:09.004 --> 00:02:11.969
预测未来位置

00:02:11.969 --> 00:02:14.400
这样太棒了

00:02:14.400 --> 00:02:16.760
这也是卡尔曼滤波器算法

00:02:16.759 --> 00:02:20.884
在人工智能及更广泛的控制理论领域

00:02:20.884 --> 00:02:23.679
为何非常受欢迎的原因之一

