WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.000
这段代码实现了完整的卡尔曼滤波器

00:00:05.000 --> 00:00:08.000
它遍历所有测量元素 并假设

00:00:08.000 --> 00:00:11.000
测量值的个数和运动值个数相同，列表的索引为 n

00:00:11.000 --> 00:00:16.000
它使用这边的这个递归公式更新 mu 和 sigma

00:00:16.000 --> 00:00:19.000
如果我们输入第 n 个测量值和测量不确定性

00:00:19.000 --> 00:00:22.000
它会对运动进行同样的操作 这里的预测部分

00:00:22.000 --> 00:00:26.000
它使用第 n 个运动和运动不确定性递归式地更新

00:00:26.000 --> 00:00:30.000
mu 和 sigma 并把这些全部打印出来

00:00:30.000 --> 00:00:34.000
如果我点击运行按钮 我会发现 第一次测量更新

00:00:34.000 --> 00:00:37.000
实际上是 5.0

00:00:37.000 --> 00:00:39.000
是 4.98

00:00:39.000 --> 00:00:42.000
这是合理的 因为我们的初始不确定性很高

00:00:42.000 --> 00:00:46.000
并且这个 5 的测量结果的不确定性相对较低

00:00:46.000 --> 00:00:50.000
实际上 我们得到的 sigma 平方项是 3.98

00:00:50.000 --> 00:00:53.000
这比 4 和 1000 要好 比 4 稍好一些

00:00:53.000 --> 00:00:56.000
我们比测量值本身的确定性更高一点

00:00:56.000 --> 00:00:58.000
现在 我们输入运动值 1

00:00:58.000 --> 00:01:00.000
我们得到 5.9

00:01:00.000 --> 00:01:04.000
我们的不确定性刚好增加了 2 从 3.98 到 5.98

00:01:04.000 --> 00:01:07.000
然后 下一次更新在 6

00:01:07.000 --> 00:01:09.000
给出了一个 5.99 的测量值

00:01:09.000 --> 00:01:13.000
现在不确定性降低为 2.39

00:01:13.000 --> 00:01:16.000
然后我们再向右移动 1

00:01:16.000 --> 00:01:19.000
将预测变为 6.99

00:01:19.000 --> 00:01:21.000
不确定性升高

00:01:21.000 --> 00:01:24.000
测量得到 7 我们得到了 6.99 很接近 7

00:01:24.000 --> 00:01:26.000
不确定性下降

00:01:26.000 --> 00:01:29.000
我们向右移动 2 测量值为 9 向右移动 1

00:01:29.000 --> 00:01:31.000
测量值为 10 然后再移动 1

00:01:31.000 --> 00:01:33.000
最后是运动

00:01:33.000 --> 00:01:36.000
如果你看一下最终结果 我们的估计非常接近 11

00:01:36.000 --> 00:01:40.000
也就是 10 + 1 的结果

00:01:40.000 --> 00:01:43.000
运动后不确定性为 4.0

00:01:43.000 --> 00:01:46.000
测量后不确定性为 2.0

00:01:46.000 --> 00:01:48.000
你刚刚写的代码

00:01:48.000 --> 00:01:52.000
实现了一个完整的一维卡尔曼滤波器

00:01:52.000 --> 00:01:54.000
你可以看一下这里

00:01:54.000 --> 00:01:56.000
我们有一个更新函数 它的实现

00:01:56.000 --> 00:02:00.000
实际上是个相对简单的方程式

00:02:00.000 --> 00:02:02.000
以及一个预测函数 这个函数更简单

00:02:02.000 --> 00:02:04.000
只是一个加法方程式

00:02:04.000 --> 00:02:07.000
然后 你将其应用到测量值序列和运动值序列上

00:02:07.000 --> 00:02:09.000
并使用对应的不确定性

00:02:09.000 --> 00:02:12.000
这里的小段代码

00:02:12.000 --> 00:02:14.000
提供了一个完整的一维卡尔曼滤波器

00:02:14.000 --> 00:02:17.000
我觉得这太神奇了

00:02:17.000 --> 00:02:19.000
我们试着输入一些其他值

00:02:19.000 --> 00:02:22.000
假设你对初始位置非常确定

00:02:22.000 --> 00:02:24.000
但它其实错了 是 0

00:02:24.000 --> 00:02:26.000
应该是 5 但这里是 0

00:02:26.000 --> 00:02:28.000
现在 我们假定一个非常低的不确定性

00:02:28.000 --> 00:02:31.000
猜一下 最终预测会如何？

00:02:31.000 --> 00:02:33.000
我点击运行按钮

00:02:33.000 --> 00:02:35.000
你会发现 最终估计已经受到了影响

00:02:35.000 --> 00:02:38.000
不是 11 只有 10.5

00:02:38.000 --> 00:02:42.000
之所以会这样 是因为刚开始的时候

00:02:42.000 --> 00:02:46.000
在我们的第一次测量更新后 我们相信位置处于 0

00:02:46.000 --> 00:02:49.000
这是 1.24 的 -10 次方

00:02:49.000 --> 00:02:52.000
但这是个很低的不确定性 甚至比这里这个更低

00:02:52.000 --> 00:02:55.000
我们执行运动更新 加 1

00:02:55.000 --> 00:02:57.000
不确定性升高

00:02:57.000 --> 00:02:59.000
然后 下一次更新 是 6

00:02:59.000 --> 00:03:01.000
我们现在更愿意相信测量值

00:03:01.000 --> 00:03:06.000
因为不确定性现在差不多是 2 而不是 0.001

00:03:06.000 --> 00:03:10.000
我们把位置更新为 2.666

00:03:10.000 --> 00:03:13.000
这距离 1 并不远 然后我们降低不确定性

00:03:13.000 --> 00:03:15.000
运动值为 3.66

00:03:15.000 --> 00:03:17.000
不确定性升高

00:03:17.000 --> 00:03:19.000
我们现在可以继续更新

00:03:19.000 --> 00:03:21.000
你可以看到在 7 这里 我们更新到 5.1

00:03:21.000 --> 00:03:26.000
但不会持续更新 因为我们非常确定 之前的估计是错的

00:03:26.000 --> 00:03:29.000
这种信心会一直延续到最后

00:03:29.000 --> 00:03:33.000
我们最终预测的是 10.5 而不是 11

00:03:33.000 --> 00:03:36.000
不确定性为 3.98

00:03:36.000 --> 00:03:38.000
所以我们纠正了部分数据

00:03:38.000 --> 00:03:41.000
我们成功将其拉回正确方向 但还是偶有错误

00:03:41.000 --> 00:03:44.000
因为我们最初的错误信念在整个方程式中

00:03:44.000 --> 99:59:59.999
的权重很高

