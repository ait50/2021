WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.669
对误差函数做个形象的比喻

00:00:02.669 --> 00:00:04.139
我们站在一座山上

00:00:04.139 --> 00:00:06.870
称之为误差之巅 （译者注：与珠穆朗玛峰音近） 我想下山

00:00:06.870 --> 00:00:10.095
但是并不轻松 因为是阴天 而且山非常大

00:00:10.095 --> 00:00:12.425
无法看到全貌

00:00:12.425 --> 00:00:15.080
我们下山的方式是看看周围

00:00:15.080 --> 00:00:18.234
考虑所有下山的可能方向

00:00:18.234 --> 00:00:21.429
然后选择一个下降高度最多的方向

00:00:21.428 --> 00:00:23.669
假设是这个方向

00:00:23.670 --> 00:00:26.100
朝着这个方向迈出一步

00:00:26.100 --> 00:00:28.789
高度降低了

00:00:28.789 --> 00:00:33.560
而后不断重复这一过程 我们始终在降低高度

00:00:33.560 --> 00:00:39.210
直到完全下山 将高度降至最低

00:00:39.210 --> 00:00:43.557
这种情况下 我们用来解决问题的关键指标就是高度

00:00:43.557 --> 00:00:45.533
我们将高度作为误差

00:00:45.533 --> 00:00:48.129
该误差可以告诉我们目前的状况有多差

00:00:48.130 --> 00:00:51.234
与理想解决方案的差别有多大

00:00:51.234 --> 00:00:54.490
如果我们不断采取措施来降低误差

00:00:54.490 --> 00:00:57.715
那么我们最终会解决问题

00:00:57.715 --> 00:00:59.399
从误差之巅上走下来

00:00:59.399 --> 00:01:00.655
有些人可能会问

00:01:00.655 --> 00:01:03.085
这并不能百分百保证解决问题呀

00:01:03.085 --> 00:01:04.329
如果困在某个山谷里怎么办

00:01:04.328 --> 00:01:06.968
只是到了一个局部最低点 但不是整座山的最低点

00:01:06.968 --> 00:01:09.067
机器学习经常会出现这种情况

00:01:09.069 --> 00:01:11.870
我们稍后将介绍解决这一问题的各种方法

00:01:11.870 --> 00:01:14.259
值得注意的是

00:01:14.259 --> 00:01:18.129
很多情况下 局部最小值已经足以很好地解决问题

00:01:18.129 --> 00:01:20.734
这种方法叫做梯度下降

00:01:20.733 --> 00:01:23.280
稍后我们将详细介绍

00:01:23.280 --> 00:01:25.424
我们试着用该方法解决一个问题

00:01:25.424 --> 00:01:27.239
这个例子中 用什么作为误差函数比较合适？

00:01:27.239 --> 00:01:30.634
用什么方式可以很好地告诉计算机当前的误差是多少？

00:01:30.634 --> 00:01:33.864
这是我们的直线以及正负区域

00:01:33.864 --> 00:01:38.385
问题是如何告诉计算机 现在距离完美的解决方案有多远？

00:01:38.385 --> 00:01:40.885
我们可以数一下错误数量

00:01:40.885 --> 00:01:42.180
这里有两个错误

00:01:42.180 --> 00:01:44.810
这是我们的高度 也就是误差

00:01:44.810 --> 00:01:46.920
就像下山一样

00:01:46.920 --> 00:01:49.409
我们朝着所有方向看去

00:01:49.409 --> 00:01:52.665
看看如何移动直线 以便降低误差

00:01:52.665 --> 00:01:54.305
假设朝着这个方向移动

00:01:54.305 --> 00:01:58.260
我们使错误数量降到 1 如果再朝着那个方向移动

00:01:58.260 --> 00:02:00.810
则使错误数量降到 0

00:02:00.810 --> 00:02:04.049
然后就解决问题了 对吧？其实只能说是几乎解决

00:02:04.049 --> 00:02:06.030
这个方法有个小问题

00:02:06.030 --> 00:02:10.995
在我们的算法中 由于微积分的原理 我们一般采取非常小的步长

00:02:10.995 --> 00:02:14.990
这一步长是用导数计算得到的

00:02:14.990 --> 00:02:17.610
在这种情况下 采用非常小的步长 会出现什么情况？

00:02:17.610 --> 00:02:23.631
一开始有两个错误 然后把直线移动一点 依然有两个错误

00:02:23.631 --> 00:02:26.574
再次移动一点 依然有两个错误

00:02:26.574 --> 00:02:30.784
再移动一些 依然是两个错误 不断重复下去

00:02:30.782 --> 00:02:32.875
这样并不能得到任何进展

00:02:32.875 --> 00:02:35.150
这就相当于使用梯度下降

00:02:35.150 --> 00:02:37.900
一步步从一座阿兹台克金字塔上走下来

00:02:37.900 --> 00:02:39.949
如果站在第二层 有两个错误

00:02:39.949 --> 00:02:42.609
我们朝四周看看

00:02:42.609 --> 00:02:46.909
我们始终看到两个错误需要减少 我们会感到困惑 不知道该怎么操作

00:02:46.907 --> 00:02:48.643
另一方面 在误差之巅

00:02:48.645 --> 00:02:51.960
我们可以得到高度的小幅变化

00:02:51.960 --> 00:02:56.224
知道哪个方向下降最多

00:02:56.223 --> 00:03:00.449
用数学术语描述 为了进行梯度下降

00:03:00.449 --> 00:03:04.818
我们的误差函数不能是离散的 而必须是连续的

00:03:04.818 --> 00:03:06.375
误差之巅的高度是连续函数

00:03:06.375 --> 00:03:09.680
因为位置上的轻微扰动会导致高度发生变化

00:03:09.680 --> 00:03:12.115
但是阿兹台克金字塔上就不会这样

00:03:12.115 --> 00:03:15.699
因为高度都是以跳跃形式从 2 到 1 而后从 1 到 0

00:03:15.699 --> 00:03:18.009
实际上 误差函数必须是可微分的

00:03:18.008 --> 00:03:20.549
稍后我们将讲解这一点

00:03:20.550 --> 00:03:22.825
我们要做的是

00:03:22.824 --> 00:03:26.484
构建一个连续误差函数 构建方法如下

00:03:26.485 --> 00:03:30.590
这是六个点 其中四个分类正确

00:03:30.590 --> 00:03:33.360
即两个蓝点和两个红点

00:03:33.360 --> 00:03:35.900
另外两个分类错误

00:03:35.900 --> 00:03:40.710
即最左侧的一个红点和最右侧的一个蓝点

00:03:40.710 --> 00:03:44.074
误差函数将向这两个分类错误的点

00:03:44.074 --> 00:03:46.469
分配大的罚值

00:03:46.467 --> 00:03:50.149
并为四个分类正确的点分配小的罚值

00:03:50.150 --> 00:03:54.004
我们将罚值用点的大小表示

00:03:54.002 --> 00:03:57.559
当点分类错误时 罚值约等于点离直线的距离

00:03:57.560 --> 00:04:02.937
当点分类正确时 则约为 0

00:04:02.937 --> 00:04:06.405
稍后我们将学习这一误差公式

00:04:06.405 --> 00:04:10.729
现在通过将所有点的误差相加 得到总误差

00:04:10.729 --> 00:04:11.990
这里有多个数字

00:04:11.990 --> 00:04:15.240
两个分类错误的点使误差增大了很多

00:04:15.240 --> 00:04:19.509
现在要移动直线 以便降低该误差

00:04:19.509 --> 00:04:23.509
现在可以实现误差函数的连续变化了 我们可以对直线参数进行小改动

00:04:23.509 --> 00:04:28.129
可以使误差函数也产生一个小的变化

00:04:28.129 --> 00:04:29.149
如果移动直线

00:04:29.149 --> 00:04:30.288
例如朝着这个方向

00:04:30.288 --> 00:04:33.365
可以看到某些点的误差降低了 另一些稍微增大了

00:04:33.365 --> 00:04:35.389
但是对于它们的总和来说

00:04:35.389 --> 00:04:39.050
是变小了 因为现在

00:04:39.050 --> 00:04:43.360
两个分类错误的点分类正确了

00:04:43.360 --> 00:04:46.774
能够构建具有这一属性的误差函数后

00:04:46.774 --> 00:04:51.240
就可以使用梯度下降来解决我们的问题了

00:04:51.240 --> 00:04:52.995
下面是整个问题的综合描述

00:04:52.995 --> 00:04:54.345
我们位于误差之巅

00:04:54.345 --> 00:04:57.810
我们站的非常高 误差很大

00:04:57.810 --> 00:05:03.639
可以看出 误差是高度 即蓝点和红点之和

00:05:03.639 --> 00:05:07.889
我们朝四周看去 看看哪个方向可以使我们下降最多

00:05:07.889 --> 00:05:11.764
也就是说 朝哪个方向移动直线可以使误差降低最多

00:05:11.764 --> 00:05:14.629
然后朝着这个方向前进一步

00:05:14.629 --> 00:05:18.838
对于误差之巅来说 我们向下走了一步 对应该图表而言

00:05:18.838 --> 00:05:22.684
我们通过正确分类其中一个点 让误差减小了一些

00:05:22.684 --> 00:05:24.014
然后再重复一遍 计算误差

00:05:24.014 --> 00:05:27.959
我们朝四周看去 看看哪个方向可以使我们下降最多

00:05:27.959 --> 00:05:32.365
然后朝着这个方向前进一步 这样就可以慢慢下山了

00:05:32.365 --> 00:05:35.430
在左图中 我们降低了高度

00:05:35.430 --> 00:05:38.250
最后成功下山

00:05:38.250 --> 00:05:45.430
在右图中 我们将误差降到最低可能值 并对所有点进行了正确分类

00:05:45.430 --> 00:05:49.093
现在的问题是 如何定义该误差函数？

00:05:49.093 --> 00:05:50.420
这就是接下来的内容

