WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.610
先说说如何创建 vocab_to_int 字典

00:00:02.610 --> 00:00:05.370
并对字词数据进行编码

00:00:05.370 --> 00:00:07.315
实现方式有多种

00:00:07.315 --> 00:00:10.920
我使用这个导入的 Counter 创建一个字典

00:00:10.920 --> 00:00:14.830
它会将影评文本中的最常见字词映射到最小的整数

00:00:14.830 --> 00:00:18.930
首先调用 Counter 并传入 words

00:00:18.930 --> 00:00:23.480
对每个字词在数据中的出现次数进行计数

00:00:23.480 --> 00:00:26.680
获得这些计数后 创建一个有序词汇表

00:00:26.680 --> 00:00:30.185
根据每个唯一字词的出现频率排序

00:00:30.185 --> 00:00:32.690
这个 vocab 包含了数据中的所有唯一字词

00:00:32.690 --> 00:00:35.210
没有任何重复字词

00:00:35.210 --> 00:00:37.235
并且按出现频率排序

00:00:37.235 --> 00:00:39.650
在用整数值编码字词时

00:00:39.650 --> 00:00:43.020
我们需要从 1（而不是 0）开始

00:00:43.020 --> 00:00:48.275
所以“the”或“of”等最常见的字词应该编码为 1

00:00:48.275 --> 00:00:51.575
在这里使用枚举并传入 vocab 和起始索引 1

00:00:51.575 --> 00:00:55.510
这样就能使索引从 1 开始

00:00:55.510 --> 00:00:58.340
enumerate 将返回一个数字值 ii

00:00:58.340 --> 00:01:02.365
以及词汇表中的一个字词enumerate 会按顺序返回

00:01:02.365 --> 00:01:04.670
所以第一个索引是 1

00:01:04.670 --> 00:01:08.795
第一个字词将是有序词汇表中的最常见字词

00:01:08.795 --> 00:01:11.150
要创建 vocab_to_int 字典

00:01:11.150 --> 00:01:13.580
需要获取 vocab 中的每个唯一字词

00:01:13.580 --> 00:01:16.190
并将它映射到从 1 开始的索引

00:01:16.190 --> 00:01:20.845
很棒接下来使用该字典标记化所有字词数据

00:01:20.845 --> 00:01:23.550
在这里查看每条影评

00:01:23.550 --> 00:01:26.315
每个影评都是 review_split 中的一个条目

00:01:26.315 --> 00:01:29.060
我之前用换行符拆分影评时创建了这个 review_split

00:01:29.060 --> 00:01:31.335
对于影评中的每个字词

00:01:31.335 --> 00:01:35.120
我都使用字典将该字词转换为整数值

00:01:35.120 --> 00:01:38.215
并将标记化的影评附加到 reviews_ints 上

00:01:38.215 --> 00:01:41.770
最终结果是一个标记化影评列表

00:01:41.770 --> 00:01:43.880
我在单元格下面

00:01:43.880 --> 00:01:47.540
输出了字典长度和第一个示例标记化影评

00:01:47.540 --> 00:01:51.205
字典长度为 74,000 多个字词

00:01:51.205 --> 00:01:55.050
也就是说 影评数据有 74,000 多个唯一字词

00:01:55.050 --> 00:01:57.290
我们来看看这条标记化影评

00:01:57.290 --> 00:02:00.379
里面没有任何 0，不错

00:02:00.379 --> 00:02:03.020
这些编码值符合预期

00:02:03.020 --> 00:02:05.575
成功编码影评字词后

00:02:05.575 --> 00:02:07.215
下一步是

00:02:07.215 --> 00:02:09.050
对标签进行编码

00:02:09.050 --> 00:02:11.000
我们需要查看标签文本数据

00:02:11.000 --> 00:02:15.840
并将“positive”转换成 1 将“negative”转换成 0

00:02:15.840 --> 00:02:18.770
我们还没有预处理标签数据

00:02:18.770 --> 00:02:23.590
不过每个标签都各占一行 与影评文本很像

00:02:23.590 --> 00:02:26.390
可以用换行符作为分隔符

00:02:26.390 --> 00:02:30.410
将加载的数据拆分成单个标签 并获得 labels_split 列表

00:02:30.410 --> 00:02:32.550
然后使用一个 for 语句

00:02:32.550 --> 00:02:35.505
对于 label_split 列表中的每个标签

00:02:35.505 --> 00:02:38.750
如果内容为“positive” 则向数组中添加 1

00:02:38.750 --> 00:02:40.555
否则向数组中添加 0

00:02:40.555 --> 00:02:42.915
将这行代码放入 np.array 中

00:02:42.915 --> 00:02:47.300
这样就能创建 encoded_labels 数组了好的

00:02:47.300 --> 00:02:50.660
数据处理得差不多了不过在定义模型之前

00:02:50.660 --> 00:02:54.305
还有几个数据清理和格式设定步骤

00:02:54.305 --> 00:02:56.730
下面我们就来完成这些步骤吧

