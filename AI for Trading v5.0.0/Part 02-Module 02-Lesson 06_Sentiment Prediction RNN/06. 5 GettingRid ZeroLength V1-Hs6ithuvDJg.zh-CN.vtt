WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.040
对所有字词和标签数据进行编码后 还要完成一个预处理步骤

00:00:05.040 --> 00:00:09.000
我们需要适当地变形影评 使所有影评都标准化

00:00:09.000 --> 00:00:12.905
也就是说 传入网络中的输入文本必须是标准大小

00:00:12.905 --> 00:00:16.885
所以我们需要将影评变形为一致的长度

00:00:16.885 --> 00:00:20.160
这个任务分成两步

00:00:20.160 --> 00:00:23.805
首先检查影评数据中是否有

00:00:23.805 --> 00:00:28.440
会扰乱训练流程的超短或超长影评

00:00:28.440 --> 00:00:32.630
例如是否有长度为 0 的影评

00:00:32.630 --> 00:00:36.830
这种影评不能提供任何文本信息 只会带来干扰

00:00:36.830 --> 00:00:39.210
如果发现这种长度为 0 的影评

00:00:39.210 --> 00:00:41.840
需要删除整个影评

00:00:41.840 --> 00:00:44.330
第二步是查看剩下的影评

00:00:44.330 --> 00:00:45.845
对于超长的影评

00:00:45.845 --> 00:00:48.710
将影评截断到特定的长度

00:00:48.710 --> 00:00:51.560
并对更短的影评执行相似的操作

00:00:51.560 --> 00:00:54.695
使所有影评的长度都一样

00:00:54.695 --> 00:00:57.440
这就是填充和截断步骤

00:00:57.440 --> 00:00:59.960
即用零列填充数据或删除某些列

00:00:59.960 --> 00:01:03.410
最终获得想要的输入形状

00:01:03.410 --> 00:01:05.520
Ok在对影评文本进行填充之前

00:01:05.520 --> 00:01:08.085
我们需要检查是否有长度为 0 的影评

00:01:08.085 --> 00:01:10.910
我将使用计数器

00:01:10.910 --> 00:01:13.985
对于数据目前具有的各种影评长度

00:01:13.985 --> 00:01:16.640
无论是长度为 0 还是有数千个字词

00:01:16.640 --> 00:01:19.370
我都会检查有多少条影评是这个长度

00:01:19.370 --> 00:01:21.640
这行代码返回一个字典 review_lens

00:01:21.640 --> 00:01:25.935
该字典会记录有多少影评长度为这些值

00:01:25.935 --> 00:01:28.660
现在查看有多少条影评长度为 0

00:01:28.660 --> 00:01:32.735
并输出最长影评的长度

00:01:32.735 --> 00:01:34.265
运行该单元格

00:01:34.265 --> 00:01:36.895
结果显示有 1 条影评的长度为 0

00:01:36.895 --> 00:01:40.365
最长的影评包含 2,000 多个单词

00:01:40.365 --> 00:01:44.415
这个长度为 0 的影评对数据集来说没什么用

00:01:44.415 --> 00:01:47.385
下面你需要创建一个新的 reviews_ints 列表

00:01:47.385 --> 00:01:50.200
以及一个 encoded_labels 数组

00:01:50.200 --> 00:01:53.650
reviews_ints 列表不能包含长度为 0 的影评

00:01:53.650 --> 00:01:55.870
所以请从该列表里删除长度为 0 的影评

00:01:55.870 --> 00:01:58.935
并删除对应的标签

00:01:58.935 --> 00:02:01.330
运行该单元格后

00:02:01.330 --> 00:02:04.130
结果应该显示 1 个影评被删掉了

00:02:04.130 --> 00:02:06.350
快来完成这道练习吧

00:02:06.350 --> 00:02:09.530
接下来我会介绍我的实现方式并布置下道练习

