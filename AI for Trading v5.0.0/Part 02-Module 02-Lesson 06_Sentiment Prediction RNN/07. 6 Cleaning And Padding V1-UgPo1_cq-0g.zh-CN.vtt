WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.605
上次我们发现有一个影评的长度为 0

00:00:04.605 --> 00:00:08.420
这条影评对训练没有任何帮助

00:00:08.420 --> 00:00:13.410
所以从 reviews_ints 列表中删除所有长度为 0 的影评

00:00:13.410 --> 00:00:16.245
并删除相应的标签

00:00:16.245 --> 00:00:19.350
对于这个任务我的思路是

00:00:19.350 --> 00:00:22.620
我需要查找所有长度为 0 的影评

00:00:22.620 --> 00:00:26.885
并从现有的 reviews_ints 列表和 encoded_labels 中删除这些影评及标签

00:00:26.885 --> 00:00:30.015
首先需要识别要保留的索引

00:00:30.015 --> 00:00:33.535
称之为 non_zero_idx

00:00:33.535 --> 00:00:37.390
检查 reviews_ints 列表中的每条影评的长度

00:00:37.390 --> 00:00:39.430
如果长度不等于 0

00:00:39.430 --> 00:00:44.355
那么我会保留它并将它的索引记录到 non_zero_idx 列表中

00:00:44.355 --> 00:00:46.730
从现有的 reviews_ints 列表

00:00:46.730 --> 00:00:50.205
和 encoded_labels 数组中获取这些索引

00:00:50.205 --> 00:00:54.525
并将新的已清理数据存储到具有相同名称的变量中

00:00:54.525 --> 00:00:56.185
检查一下列表长度

00:00:56.185 --> 00:00:59.510
可以看出已经删除了一条影评

00:00:59.510 --> 00:01:03.315
由于数据中只有一条长度为 0 的影评 所以结果符合预期

00:01:03.315 --> 00:01:05.660
接下来需要处理超长的影评

00:01:05.660 --> 00:01:10.625
并使影评长度标准化

00:01:10.625 --> 00:01:13.360
我们之前看到最长的影评包含 2,500 多个字词

00:01:13.360 --> 00:01:17.585
这么长的影评需要很多 RNN 训练步数

00:01:17.585 --> 00:01:19.550
对于这种情形

00:01:19.550 --> 00:01:22.375
我们会将数据截断到合理的长度并训练合理的步数

00:01:22.375 --> 00:01:24.535
下面说说下道练习

00:01:24.535 --> 00:01:27.335
对于超短和超长的影评

00:01:27.335 --> 00:01:32.240
我们将通过填充或截断方式将影评变成特定的长度

00:01:32.240 --> 00:01:34.880
如果影评比某个长度短

00:01:34.880 --> 00:01:37.355
我们将在左侧填充 0

00:01:37.355 --> 00:01:39.475
如果影评比某个长度长

00:01:39.475 --> 00:01:43.155
则从前面截取特定的长度

00:01:43.155 --> 00:01:45.015
举个填充示例

00:01:45.015 --> 00:01:47.330
这是一个很短的序列

00:01:47.330 --> 00:01:50.345
假设我们希望序列长度等于 10

00:01:50.345 --> 00:01:53.570
填充后的序列应该是这样的

00:01:53.570 --> 00:01:58.385
左边填充了 7 个 0 原来的三个标记放在了末尾

00:01:58.385 --> 00:02:00.250
如果是很长的影评

00:02:00.250 --> 00:02:02.790
直接截取长度为 10 的序列

00:02:02.790 --> 00:02:06.530
这只是一个小示例

00:02:06.530 --> 00:02:09.565
对于影评数据来说 合适的序列长度是 200 左右

00:02:09.565 --> 00:02:13.410
下面这道练习题是完成 pad_features 函数

00:02:13.410 --> 00:02:17.045
该函数的参数包括 reviews_ints 列表和 seq_length

00:02:17.045 --> 00:02:21.205
它应该填充或截断所传入列表中的每个影评

00:02:21.205 --> 00:02:24.665
并返回一个转换后影评数组

00:02:24.665 --> 00:02:27.980
称之为 features

00:02:27.980 --> 00:02:31.640
它们是长度相同的标记化影评

00:02:31.640 --> 00:02:35.720
我们通常将这种转换后的数据称为模型输入特征

00:02:35.720 --> 00:02:39.440
features 数组中的每行将是标准长度的转换后影评

00:02:39.440 --> 00:02:44.145
我们可以将该数组传入模型中

00:02:44.145 --> 00:02:47.675
请完成这道练习 我在下个单元格中

00:02:47.675 --> 00:02:51.410
添加了一些输出和断言语句 这些语句可以测试 features 数组的形状

00:02:51.410 --> 00:02:55.200
接下来我将介绍我的实现方式

