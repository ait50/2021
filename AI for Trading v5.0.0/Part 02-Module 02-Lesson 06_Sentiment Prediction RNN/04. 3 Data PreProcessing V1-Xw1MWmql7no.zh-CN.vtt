WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.715
下面开始创建情感分析 RNN

00:00:02.715 --> 00:00:06.220
首先从数据目录中加载数据

00:00:06.220 --> 00:00:10.980
里面有两个文件：reviews.txt 和 labels.txt

00:00:10.980 --> 00:00:13.800
分别代表影评数据

00:00:13.800 --> 00:00:16.875
和相应的标签（正面或负面）

00:00:16.875 --> 00:00:20.315
加载这两个文件并输出其中的一些内容

00:00:20.315 --> 00:00:22.905
这是一段示例影评文本

00:00:22.905 --> 00:00:25.800
评论的是喜剧《Bromwell High》

00:00:25.800 --> 00:00:28.710
这些是标签文件里的文本

00:00:28.710 --> 00:00:31.225
内容只有“positive”和“negative”

00:00:31.225 --> 00:00:33.570
现在只有一条影评

00:00:33.570 --> 00:00:35.680
输出多条影评看看

00:00:35.680 --> 00:00:38.270
好的这是第二条影评

00:00:38.270 --> 00:00:41.750
这两个影评用换行符分开了

00:00:41.750 --> 00:00:44.800
“positive”和“negative”也用换行符分开了

00:00:44.800 --> 00:00:48.770
我们需要预处理数据并将词汇表中的所有字词标记化

00:00:48.770 --> 00:00:53.180
变成数字数据 之后才能传入模型中

00:00:53.180 --> 00:00:55.140
由于我们会使用一个嵌入层

00:00:55.140 --> 00:00:56.840
所以需要将每个字词表示为整数

00:00:56.840 --> 00:01:00.190
并且需要清理数据

00:01:00.190 --> 00:01:02.900
第一个预处理步骤是

00:01:02.900 --> 00:01:06.505
将文本全变成小写形式并删除多余的标点

00:01:06.505 --> 00:01:08.305
标点符号

00:01:08.305 --> 00:01:10.160
对于将影评分类为正面还是负面影评

00:01:10.160 --> 00:01:13.175
没有多大的影响

00:01:13.175 --> 00:01:14.660
Ok在这个单元格中

00:01:14.660 --> 00:01:16.610
将所有影评文本转换为小写形式

00:01:16.610 --> 00:01:20.640
并删除所有标点

00:01:20.640 --> 00:01:23.155
在这里使用内置的 Python 列表

00:01:23.155 --> 00:01:25.225
from string import punctuation

00:01:25.225 --> 00:01:27.220
输出所有标点

00:01:27.220 --> 00:01:31.435
punctuation 是一个包含所有这些标点字符的列表

00:01:31.435 --> 00:01:34.280
对于影评文本 我将查看每个字符

00:01:34.280 --> 00:01:36.920
如果它不在 punctuation 列表中 则保留该字符

00:01:36.920 --> 00:01:40.835
返回一个没有标点的影评文本版本

00:01:40.835 --> 00:01:43.360
将该版本存储到变量 all_text 中

00:01:43.360 --> 00:01:48.990
影评是用换行符 \n 区分的

00:01:48.990 --> 00:01:50.430
所以我将在这里使用 \n 作为分隔符

00:01:50.430 --> 00:01:55.000
将文本拆分为多个影评条目

00:01:55.000 --> 00:01:58.740
然后将所有影评连到一起 变成一个很长的字符串

00:01:58.740 --> 00:02:00.710
最终目标是

00:02:00.710 --> 00:02:03.765
将文本拆分为单个字词

00:02:03.765 --> 00:02:06.980
运行该单元格并输出前 30 个字词

00:02:06.980 --> 00:02:08.910
结果符合预期

00:02:08.910 --> 00:02:11.360
还是原来的文本

00:02:11.360 --> 00:02:16.480
但是删掉了所有的标点 并且拆分成了一个个字词

00:02:16.480 --> 00:02:18.080
准备好数据后

00:02:18.080 --> 00:02:20.375
你已经知道下一步该干嘛了

00:02:20.375 --> 00:02:22.460
我们需要获取字词数据和标签文本数据

00:02:22.460 --> 00:02:26.225
并转换为数字数据

00:02:26.225 --> 00:02:29.135
下面说说前几道练习题

00:02:29.135 --> 00:02:34.430
首先需要创建一个 vocab_to_int 字典 它会将唯一字词转换为整数标记

00:02:34.430 --> 00:02:36.165
然后使用该字典

00:02:36.165 --> 00:02:39.375
新建一个标记化字词列表

00:02:39.375 --> 00:02:43.145
其中包含所有字词对应的整数值

00:02:43.145 --> 00:02:48.545
该字典需要将更频繁的字词映射到更小的整数标记

00:02:48.545 --> 00:02:51.320
请注意

00:02:51.320 --> 00:02:54.180
之后我们会用零填充输入向量

00:02:54.180 --> 00:02:57.005
所以不能将零设为字词标记

00:02:57.005 --> 00:02:59.725
标记值应该从 1 开始

00:02:59.725 --> 00:03:05.110
词汇表中最常见的字词应该映射到整数值 1

00:03:05.110 --> 00:03:06.860
总结下 先创建该字典

00:03:06.860 --> 00:03:08.630
使用该字典标记化字词

00:03:08.630 --> 00:03:12.200
然后将这些标记存储到 reviews_ints 列表中

00:03:12.200 --> 00:03:16.430
下面是一些测试代码

00:03:16.430 --> 00:03:19.040
它将输出词汇表的长度

00:03:19.040 --> 00:03:21.980
以及标记化影评列表中的第一条影评

00:03:21.980 --> 00:03:27.945
下道练习是将标签文本变成数字值

00:03:27.945 --> 00:03:31.910
这些文本只包含“positive”和“negative”内容

00:03:31.910 --> 00:03:34.640
请创建一个 encoded_labels 数组

00:03:34.640 --> 00:03:38.015
将“positive”转换为 1 并将“negative”转换为 0

00:03:38.015 --> 00:03:40.250
我没有提供任何测试代码

00:03:40.250 --> 00:03:42.410
但是建议你养成良好习惯

00:03:42.410 --> 00:03:44.990
每编写一段代码都记得测试代码

00:03:44.990 --> 00:03:46.910
其实很简单

00:03:46.910 --> 00:03:48.980
添加几个输出语句就搞定了

00:03:48.980 --> 00:03:52.990
可以检查数据转换是否符合预期 或者大小是否正确 等等

00:03:52.990 --> 00:03:55.295
这些测试代码之后很有用

00:03:55.295 --> 00:03:57.830
因为代码块都是相互关联的

00:03:57.830 --> 00:04:00.295
要学会经常调试代码

00:04:00.295 --> 00:04:03.860
Ok试着对字词和标签进行编码吧

00:04:03.860 --> 00:04:06.290
如果遇到问题

00:04:06.290 --> 00:04:08.870
请观看下个 solution 视频

