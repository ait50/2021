WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.940
这是我完成的 get_batches 代码 它会生成迷你批次的数据

00:00:04.940 --> 00:00:07.530
首先

00:00:07.530 --> 00:00:11.170
我想获取能够获得的总批次数量 n_batches

00:00:11.170 --> 00:00:16.040
第一步是计算一个完整的迷你批次中有多少个字符

00:00:16.040 --> 00:00:17.430
在一个迷你批次中

00:00:17.430 --> 00:00:21.200
字符数量是 batch_size * seq_length

00:00:21.200 --> 00:00:24.270
我们能够创建的总批次数量是

00:00:24.270 --> 00:00:28.470
数组长度除以单个迷你批次中的字符数

00:00:28.470 --> 00:00:31.085
这个双斜杠表示整数除法

00:00:31.085 --> 00:00:34.365
它会对除法结果向下舍入

00:00:34.365 --> 00:00:37.640
这样就获得了能够创建的总批次数量

00:00:37.640 --> 00:00:40.550
然后获取数组并从该数组中拿出

00:00:40.550 --> 00:00:45.275
直到 n_batches * batch_size_total 个字符前的字符

00:00:45.275 --> 00:00:47.390
在这里确保仅保留

00:00:47.390 --> 00:00:49.850
足够创建完整批次所需的字符

00:00:49.850 --> 00:00:51.715
我们可能会丢失一些字符

00:00:51.715 --> 00:00:54.410
但是通常数据都足够多

00:00:54.410 --> 00:00:57.345
删除最后一个不完整的批次影响不大

00:00:57.345 --> 00:01:00.350
接下来 对于 reshape()

00:01:00.350 --> 00:01:03.465
我们可以获取数组并使行数等于 batch_size

00:01:03.465 --> 00:01:06.920
表示我们希望在一个迷你批次中包含的序列数量

00:01:06.920 --> 00:01:09.200
我们希望行数等于 batch_size

00:01:09.200 --> 00:01:12.110
然后在这里传入 -1

00:01:12.110 --> 00:01:15.360
-1 是一种维度占位符

00:01:15.360 --> 00:01:17.975
它将自动填充第二个维度

00:01:17.975 --> 00:01:21.145
从而包含所有数据

00:01:21.145 --> 00:01:26.555
最后 使用长度为 seq_length 的窗口遍历批次数据

00:01:26.555 --> 00:01:31.855
在这里接受变形后的完整数组 然后查看所有行（所有批次）

00:01:31.855 --> 00:01:36.980
列数范围是从 n 到 n+seq_length

00:01:36.980 --> 00:01:38.790
表示长度为 seq_length 的窗口

00:01:38.790 --> 00:01:41.650
这样就获得了输入迷你批次 x

00:01:41.650 --> 00:01:44.930
然后对于目标 y

00:01:44.930 --> 00:01:48.860
将数组中的值全初始化为零 并且形状和 x 一样

00:01:48.860 --> 00:01:52.730
然后用 x 数组中的值填充该数组并且偏移一个位置

00:01:52.730 --> 00:01:54.440
从到到尾

00:01:54.440 --> 00:01:56.775
使 x 偏移一个位置

00:01:56.775 --> 00:01:59.840
如果抵达数组的末尾

00:01:59.840 --> 00:02:04.310
则使 y 的最后一个元素等于该数组中的第一个元素

00:02:04.310 --> 00:02:06.425
很多人喜欢将数组前后连起来

00:02:06.425 --> 00:02:11.095
使 y 的最后一个元素等于 x 的第一个元素 我不太确定为何这么做

00:02:11.095 --> 00:02:12.495
但是我多次见到这种做法

00:02:12.495 --> 00:02:14.450
所以我也这么循环

00:02:14.450 --> 00:02:16.580
似乎网络训练效果很好

00:02:16.580 --> 00:02:18.435
所以这么做不成问题

00:02:18.435 --> 00:02:21.775
我们的目标是希望 x 和 y 是一样形状的

00:02:21.775 --> 00:02:24.940
如果你的代码正确并且想要测试代码

00:02:24.940 --> 00:02:27.595
你的批次数据应该看起来这样

00:02:27.595 --> 00:02:29.450
批次大小是 8

00:02:29.450 --> 00:02:30.920
所以这里有 8 行

00:02:30.920 --> 00:02:33.495
我们按顺序输出前 10 项

00:02:33.495 --> 00:02:35.205
所以这里应该有 10 项

00:02:35.205 --> 00:02:39.955
最重要的是确保 x 中的元素

00:02:39.955 --> 00:02:41.750
即实际编码值

00:02:41.750 --> 00:02:43.915
在 y 中向右偏移一个位置

00:02:43.915 --> 00:02:48.965
所以 51 在这里是第 1 项 在这里是第 0 项

00:02:48.965 --> 00:02:51.140
然后是 23 和 23

00:02:51.140 --> 00:02:55.280
同理 55 在这里 然后在 y 中 55 在这里我希望

00:02:55.280 --> 00:02:57.245
所有值都正确偏移

00:02:57.245 --> 00:02:59.420
看起来没问题

00:02:59.420 --> 00:03:01.160
获得批次数据后

00:03:01.160 --> 00:03:04.530
下一步我们将讨论如何实际构建网络

