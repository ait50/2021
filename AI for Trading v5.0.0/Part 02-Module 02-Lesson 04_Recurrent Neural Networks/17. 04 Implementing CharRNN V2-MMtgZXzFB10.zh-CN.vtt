WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.630
在此 notebook 中 我们将构建一个字符级 RNN

00:00:03.630 --> 00:00:06.420
并使用小说《安娜·卡列尼娜》中的文本训练此 RNN

00:00:06.420 --> 00:00:09.345
这是一部伟大的小说 但也是个悲剧

00:00:09.345 --> 00:00:11.220
我们将

00:00:11.220 --> 00:00:13.380
一次向递归神经网络中

00:00:13.380 --> 00:00:15.870
传入一个字符

00:00:15.870 --> 00:00:18.090
我们将用一大段文本训练此 RNN

00:00:18.090 --> 00:00:19.595
最终

00:00:19.595 --> 00:00:22.170
该网络将能够生成新的文本

00:00:22.170 --> 00:00:23.750
一次生成一个字符

00:00:23.750 --> 00:00:25.475
基本结构就是这样的

00:00:25.475 --> 00:00:28.980
这是输入字符 我们希望对它们进行独热编码

00:00:28.980 --> 00:00:32.819
然后将此独热编码向量传入隐藏递归层

00:00:32.819 --> 00:00:35.215
隐藏层有两个输入

00:00:35.215 --> 00:00:37.680
首先生成 RNN 输出

00:00:37.680 --> 00:00:39.015
并生成隐藏状态

00:00:39.015 --> 00:00:41.000
它将继续变化

00:00:41.000 --> 00:00:43.850
并在序列的下个时间步传入此隐藏层

00:00:43.850 --> 00:00:46.785
我们在上个代码示例中见过类似情况

00:00:46.785 --> 00:00:49.880
递归层会记录隐藏状态

00:00:49.880 --> 00:00:53.625
输出传入最终全连接输出层

00:00:53.625 --> 00:00:55.070
线性输出层

00:00:55.070 --> 00:00:57.320
将生成一系列字符类别分数

00:00:57.320 --> 00:01:00.035
这个输出将与输入向量一样长

00:01:00.035 --> 00:01:02.150
我们可以对其应用 Softmax 函数

00:01:02.150 --> 00:01:05.855
获得下个概率最高字符的概率分布

00:01:05.855 --> 00:01:11.190
此网络是基于 Andrej Karpathy 的 RNN 帖子

00:01:11.190 --> 00:01:14.920
这是一篇很精彩的帖子 你可以点击这些链接并详细了解 RNN

00:01:14.920 --> 00:01:19.945
此 notebook 分成多个小练习 你可以自己完成这些练习

00:01:19.945 --> 00:01:23.615
对于每道练习 我都会提供答案

00:01:23.615 --> 00:01:25.910
建议在一个窗口中打开练习 notebook

00:01:25.910 --> 00:01:28.280
并在另一个窗口中观看视频

00:01:28.280 --> 00:01:30.180
这样就可以跟着视频操作

00:01:30.180 --> 00:01:31.845
首先

00:01:31.845 --> 00:01:34.420
我将加载并查看文本数据

00:01:34.420 --> 00:01:35.920
在这里加载《安娜·卡列尼娜》文本文件

00:01:35.920 --> 00:01:40.285
并输出前 100 个字符

00:01:40.285 --> 00:01:43.230
这些字符包括字母 空格 换行符等

00:01:43.230 --> 00:01:46.815
这是小说的第一行文字

00:01:46.815 --> 00:01:48.465
“Happy families are all alike;

00:01:48.465 --> 00:01:51.345
Every unhappy family is unhappy in its own way.”

00:01:51.345 --> 00:01:55.220
我希望将文本转换为数字标记

00:01:55.220 --> 00:01:58.280
因为网络只能从数字数据中学习规律

00:01:58.280 --> 00:02:02.060
所以我们希望将文本中的每个字符映射到唯一索引

00:02:02.060 --> 00:02:04.395
首先 对于文本

00:02:04.395 --> 00:02:07.410
我们可以创建唯一词汇表集合

00:02:07.410 --> 00:02:09.965
集合是内置的 python 数据结构

00:02:09.965 --> 00:02:13.385
它会查看传入文本中的每个字符

00:02:13.385 --> 00:02:16.739
将文本划分为字符串并删除重复项

00:02:16.739 --> 00:02:20.325
chars 将是包含所有唯一字符的集合

00:02:20.325 --> 00:02:23.655
有时候称为词汇表

00:02:23.655 --> 00:02:27.980
然后根据包含所有字符的词汇表创建字典

00:02:27.980 --> 00:02:31.430
将实际字符映射到唯一整数

00:02:31.430 --> 00:02:35.660
即为每个唯一字符设定一个数字值

00:02:35.660 --> 00:02:38.210
并放入字典 int2char 中

00:02:38.210 --> 00:02:39.920
然后反过来

00:02:39.920 --> 00:02:43.429
有一个将整数映射到字符的字典

00:02:43.429 --> 00:02:47.270
字典由键值对组成

00:02:47.270 --> 00:02:48.950
在 int2char 字典中

00:02:48.950 --> 00:02:53.070
键是整数 值是字符串

00:02:53.070 --> 00:02:54.740
在 char2int 字典中

00:02:54.740 --> 00:02:56.780
键是字符

00:02:56.780 --> 00:02:59.430
值是唯一整数

00:02:59.430 --> 00:03:03.265
这样就能够将文本表示为数字

00:03:03.265 --> 00:03:05.155
在这里

00:03:05.155 --> 00:03:08.855
将文本中的每个字符表示为整数

00:03:08.855 --> 00:03:11.045
这会生成编码后的文本

00:03:11.045 --> 00:03:14.000
之前输出了前 100 个字符

00:03:14.000 --> 00:03:16.670
现在也可以输出前 100 个编码值

00:03:16.670 --> 00:03:19.099
查看唯一字符集的长度

00:03:19.099 --> 00:03:21.850
可以看出文本有 83 个唯一字符

00:03:21.850 --> 00:03:24.500
编码值将在此范围内

00:03:24.500 --> 00:03:27.765
还有一些重复的值

00:03:27.765 --> 00:03:30.800
例如 82 82 82 以及 19 19

00:03:30.800 --> 00:03:32.675
上拉到实际文本部分

00:03:32.675 --> 00:03:36.590
可以猜测重复的 82 可能表示这个换行符

00:03:36.590 --> 00:03:39.110
19 可能表示 p

00:03:39.110 --> 00:03:40.405
编码正确

00:03:40.405 --> 00:03:41.710
现在我们希望

00:03:41.710 --> 00:03:44.105
将这些编码变成独热向量

00:03:44.105 --> 00:03:46.060
并能够作为 RNN 的输入

00:03:46.060 --> 00:03:47.950
和一开始的图表一样

00:03:47.950 --> 00:03:51.770
我在这里创建了一个函数

00:03:51.770 --> 00:03:54.710
它会接受编码数组并转换为指定长度的独热向量

00:03:54.710 --> 00:03:58.095
我将在下面用个示例讲解此函数的作用

00:03:58.095 --> 00:04:00.930
我创建了一个简短的测试序列 [3, 5, 1]

00:04:00.930 --> 00:04:03.975
并且将向量长度指定为 8

00:04:03.975 --> 00:04:06.530
将此测试序列和想要的标签数量

00:04:06.530 --> 00:04:09.765
传入独热函数中

00:04:09.765 --> 00:04:14.085
结果是一个数组 包含 3 个独热向量

00:04:14.085 --> 00:04:17.440
所有这些向量的长度为 8

00:04:17.440 --> 00:04:20.760
在索引 3、5 和 1 处的相应编码已开启

00:04:20.760 --> 00:04:23.480
对于有 83 个字符的词汇表

00:04:23.480 --> 00:04:25.745
这个数组将是长得多的向量

00:04:25.745 --> 00:04:30.260
好的创建好预处理函数和数据后

00:04:30.260 --> 00:04:33.380
现在的第一个任务是把被编码的字符

00:04:33.380 --> 00:04:36.975
变成能传入网络中的迷你批次

00:04:36.975 --> 00:04:38.910
正如 Matt 之前提到的

00:04:38.910 --> 00:04:40.880
我们希望一次

00:04:40.880 --> 00:04:43.430
有多个序列经过网络

00:04:43.430 --> 00:04:47.110
一个迷你批次的数据包含多个序列

00:04:47.110 --> 00:04:49.695
这是一个示例起始序列

00:04:49.695 --> 00:04:51.620
如果我们希望批次大小为 2

00:04:51.620 --> 00:04:54.405
我们将此数据划分为两个批次

00:04:54.405 --> 00:04:57.110
这些是序列长度的窗口

00:04:57.110 --> 00:04:59.555
指定序列有多大

00:04:59.555 --> 00:05:01.880
这里的序列长度是 3

00:05:01.880 --> 00:05:03.900
所以窗口宽度将是 3

00:05:03.900 --> 00:05:06.320
对于批次大小 2 和序列长度 3

00:05:06.320 --> 00:05:09.370
这些值将构成第一个迷你批次

00:05:09.370 --> 00:05:12.950
使这个窗口滑动 3 个单位 获得下个迷你批次

00:05:12.950 --> 00:05:17.370
每个迷你批次的维度将是批次大小 x 序列长度

00:05:17.370 --> 00:05:20.120
这里是在传入网络的编码数组上的

00:05:20.120 --> 00:05:22.840
2x3 窗口

00:05:22.840 --> 00:05:26.345
下拉可以看到更多具体说明

00:05:26.345 --> 00:05:30.355
首先接受编码数组

00:05:30.355 --> 00:05:35.320
并丢弃完整迷你批次多出来的值

00:05:35.320 --> 00:05:39.605
然后调整此数组的形状 使其行数为批次大小

00:05:39.605 --> 00:05:41.630
创建批次数据后

00:05:41.630 --> 00:05:43.655
创建一个窗口

00:05:43.655 --> 00:05:45.920
每次以序列长度对批次数据进行迭代

00:05:45.920 --> 00:05:47.410
以获得迷你批次

00:05:47.410 --> 00:05:49.080
这是框架代码

00:05:49.080 --> 00:05:51.590
数组将是编码数据

00:05:51.590 --> 00:05:54.385
这是批次大小和序列长度

00:05:54.385 --> 00:05:57.590
你需要创建一个输入 x

00:05:57.590 --> 00:06:01.805
宽为序列长度或时间步数 高为批次大小

00:06:01.805 --> 00:06:05.870
这样就构成了输入数据 还需要提供目标

00:06:05.870 --> 00:06:10.695
此网络的目标 y 和输入字符 x 类似

00:06:10.695 --> 00:06:12.550
但是偏移了一个字符

00:06:12.550 --> 00:06:14.750
因为我们希望网络根据输入序列

00:06:14.750 --> 00:06:17.965
预测下个最有可能的字符

00:06:17.965 --> 00:06:22.550
所以输入序列是 x  目标y 偏移一位

00:06:22.550 --> 00:06:24.955
最后 当我们调用 get_batches() 时

00:06:24.955 --> 00:06:27.110
我们将创建一个生成器

00:06:27.110 --> 00:06:30.635
它会遍历数组并使用此 yield 命令返回 x 和 y

00:06:30.635 --> 00:06:33.825
现在请你实现这个批次函数

00:06:33.825 --> 00:06:37.050
你可以在 notebook 中详细了解如何实现此函数

00:06:37.050 --> 00:06:39.925
下面提供了测试实现方法的代码

00:06:39.925 --> 00:06:43.570
当你运行此代码时 你的批次数据应该看起来这样

00:06:43.570 --> 00:06:46.460
如果需要帮助或想查看我的答案

00:06:46.460 --> 00:06:49.470
请观看下个 solution 视频

