WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.960
我们用 NumPy 的 random.randint 和 random.choice 生成随机数

00:00:03.960 --> 00:00:08.759
模拟了事件结果

00:00:08.759 --> 00:00:11.039
但是 模拟大型二项实验 例如掷硬币

00:00:11.039 --> 00:00:14.729
有一个更好的函数

00:00:14.730 --> 00:00:18.152
这里可以看到 NumPy 的 random.binomial (随机二项) 函数

00:00:18.152 --> 00:00:20.818
模拟事件数量 n

00:00:20.818 --> 00:00:24.585
每个事件的成功概率是 p

00:00:24.585 --> 00:00:29.362
成功是事件两个结果的其中之一

00:00:29.362 --> 00:00:32.280
两个结果中的一个就是成功

00:00:32.280 --> 00:00:35.984
例如 如果我们的事件是把一枚公平硬币掷 10 次

00:00:35.984 --> 00:00:38.792
我们可以把成功定义为正面朝上的次数

00:00:38.792 --> 00:00:41.380
n 是掷硬币的次数

00:00:41.380 --> 00:00:42.855
现在这种情况下是 10

00:00:42.854 --> 00:00:48.164
p 是每次抛掷时正面朝上的概率 即 0.5

00:00:48.164 --> 00:00:49.225
我们试验一下

00:00:49.225 --> 00:00:54.109
设 n 等于 10 p 等于 0.5

00:00:54.109 --> 00:00:58.979
注意 返回的是 1 个整数 而不是 10 个结果的数组

00:00:58.979 --> 00:01:02.625
由于这个函数仅适用于二项结果

00:01:02.625 --> 00:01:07.125
可以通过返回成功次数简化输出

00:01:07.125 --> 00:01:08.700
现在这种情况下是 4

00:01:08.700 --> 00:01:10.760
这是正面朝上的次数

00:01:10.760 --> 00:01:13.770
我们可以进行多次模拟

00:01:13.769 --> 00:01:15.899
我们进行 20 次

00:01:15.900 --> 00:01:18.930
这个数组中的每个数字代表每次实验中

00:01:18.930 --> 00:01:23.340
正面朝上的次数 每次实验掷 10 次硬币

00:01:23.340 --> 00:01:26.290
这是第一次实验中掷10 次硬币正面朝上的次数

00:01:26.290 --> 00:01:30.284
这个是第二次实验中掷 10 次硬币正面朝上的次数 等等

00:01:30.284 --> 00:01:33.969
总共 20 次实验

00:01:33.969 --> 00:01:37.125
我们算一下这些实验中正面朝上的平均次数

00:01:37.125 --> 00:01:38.719
由于这是一枚公平硬币

00:01:38.719 --> 00:01:41.269
我们预计这个均值接近 5

00:01:41.269 --> 00:01:43.872
可以看出 这个结果稍微有些偏差

00:01:43.873 --> 00:01:46.740
可能是因为我们只进行了 20 次实验

00:01:46.739 --> 00:01:49.724
我们看一下 如果增加实验次数 会发生什么

00:01:49.724 --> 00:01:51.572
由于这些事件是随机的

00:01:51.572 --> 00:01:56.549
无法保证每次模拟都能完全平均地获得五次正面

00:01:56.549 --> 00:01:59.219
但是 随着实验次数的增加

00:01:59.219 --> 00:02:03.045
模拟结果能更好地反映硬币的公平性

00:02:03.045 --> 00:02:07.390
在进行 1 万次实验的情况下 均值更接近五次正面

00:02:07.390 --> 00:02:12.439
我们用 matplotlib 绘制这次模拟结果的直方图

00:02:12.439 --> 00:02:17.000
和预期一样 分布情况是集中在五次正面周围

