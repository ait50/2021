WEBVTT
Kind: captions
Language: ja-JP

00:00:00.000 --> 00:00:01.780
では まとめです

00:00:01.780 --> 00:00:05.070
すべての学生の データが あります

00:00:05.070 --> 00:00:09.629
青い点は 合格で 赤い点は 不合格です

00:00:09.630 --> 00:00:15.705
モデルの式は 2x1テスト+成績-18 で

00:00:15.705 --> 00:00:18.390
これが スコアが 0である 位置を

00:00:18.390 --> 00:00:22.140
示す 境界となります

00:00:22.140 --> 00:00:26.445
予測は スコアが 0以上なら 学生は合格で

00:00:26.445 --> 00:00:28.839
スコアが 負の値なら 不合格です

00:00:28.839 --> 00:00:31.440
ここで パーセプトロンの概念が 登場します

00:00:31.440 --> 00:00:33.359
パーセプトロンは ニューラルネットワークの 構成要素で

00:00:33.359 --> 00:00:36.310
モデル式を 小さなグラフに エンコードしたものです

00:00:36.310 --> 00:00:38.625
この例では 次のように 作成しました

00:00:38.625 --> 00:00:42.475
まず データと 境界を ノードに含めます

00:00:42.475 --> 00:00:44.760
そこに 入力用の小さなノードを 追加します

00:00:44.759 --> 00:00:47.619
ここでの入力は テストと 成績です

00:00:47.619 --> 00:00:52.399
例として テスト=7と 成績=6 を使います

00:00:52.399 --> 00:00:55.439
パーセプトロンは (7, 6)の点をプロットし

00:00:55.439 --> 00:00:59.259
それが 正の領域にあるか 負の領域にあるかを 調べます

00:00:59.259 --> 00:01:00.640
点が 正の領域にある場合

00:01:00.640 --> 00:01:02.009
パーセプトロンは yesを 戻します

00:01:02.009 --> 00:01:05.784
点が 負の領域にある場合は noを戻します

00:01:05.784 --> 00:01:08.879
さて もう一度 思い出してみると

00:01:08.879 --> 00:01:12.689
式は 2xテスト+1x成績-18

00:01:12.689 --> 00:01:15.149
そして 予測は スコアが0以上なら

00:01:15.150 --> 00:01:17.550
学生は合格 スコアが 負の値なら

00:01:17.549 --> 00:01:20.709
学生は不合格 です

00:01:20.709 --> 00:01:23.849
この 2 1 -18と いう 重みは

00:01:23.849 --> 00:01:27.596
線形方程式を 定義するものなので

00:01:27.596 --> 00:01:30.409
ラベルとして グラフに 加えてみましょう

00:01:30.409 --> 00:01:34.484
2と 1は それぞれ X1と X2から出たエッジの ラベルになり

00:01:34.484 --> 00:01:38.655
-18は ノードのラベルに なります

00:01:38.655 --> 00:01:40.799
こうすると ノードと そのラベルを 見ただけで

00:01:40.799 --> 00:01:44.384
生成される 線形方程式が わかります

00:01:44.385 --> 00:01:48.165
このノードを 把握するための 別の方法では バイアスを 入力の一部と 考えます

00:01:48.165 --> 00:01:51.815
W1には X1をかけ W2には X2を かけるので

00:01:51.814 --> 00:01:54.609
Bには 1を かけると 考えるのが自然です

00:01:54.609 --> 00:01:58.983
そこで 1から出たエッジに Bのラベルを つけます

00:01:58.983 --> 00:02:01.890
すると ノードは 入力ノードから受け取った 値に

00:02:01.890 --> 00:02:05.760
対応するエッジの 値を かけます

00:02:05.760 --> 00:02:07.300
そして 求めた値を 合計し

00:02:07.299 --> 00:02:10.240
最後に 結果が 0以上か どうかを 調べます

00:02:10.240 --> 00:02:14.260
0以上であれば ノードは yes または 1の値を 戻し

00:02:14.259 --> 00:02:18.924
負の値であれば no または 0の値を 戻します

00:02:18.925 --> 00:02:20.760
このクラスでは 両方の表記法を 使いますが

00:02:20.759 --> 00:02:23.474
2番目の方が より頻繁に 使われます

00:02:23.474 --> 00:02:24.948
一般的なケースでは

00:02:24.949 --> 00:02:26.690
ノードは 次のようになります

00:02:26.689 --> 00:02:29.789
ここにあるノードが 入力を 受け取ります

00:02:29.789 --> 00:02:34.344
入力は X1～Xnと 1の値です

00:02:34.344 --> 00:02:38.294
エッジは 重みが W1～Wnで

00:02:38.294 --> 00:02:42.179
Bは バイアスユニットを 指します

00:02:42.180 --> 00:02:45.629
ノードは Wx+Bという 線形法的式を 計算します

00:02:45.629 --> 00:02:49.757
これは WiXi+Bの

00:02:49.757 --> 00:02:53.545
i=1～nの 総和です

00:02:53.545 --> 00:02:57.314
ノードは 値が 0以上かどうかを 調べ

00:02:57.314 --> 00:03:01.889
0以上なら yesを表す 1を戻し

00:03:01.889 --> 00:03:05.844
負の値なら noを表す 0を戻します

00:03:05.844 --> 00:03:07.650
ここで ステップ関数と 呼ばれる

00:03:07.650 --> 00:03:10.340
陰関数を 使っていることに 注意してください

00:03:10.340 --> 00:03:14.325
ステップ関数は 入力が 0以上なら 1を戻し

00:03:14.324 --> 00:03:16.919
入力が 負の値なら 0を戻します

00:03:16.919 --> 00:03:21.389
つまり 現実には パーセプトロンは ノードの組み合わせであり

00:03:21.389 --> 00:03:23.879
最初のノードが 入力と重みを 使って 線形方程式を 計算し

00:03:23.879 --> 00:03:28.782
2番目のノードが 結果に ステップ関数を適用します

00:03:28.782 --> 00:03:30.704
これは 次のように グラフ化できます

00:03:30.705 --> 00:03:34.005
最初のノードの シグマは 線形方程式を 表し

00:03:34.004 --> 00:03:37.305
2番目のノードの グラフは ステップ関数を 表します

00:03:37.305 --> 00:03:40.110
今後は 異なるステップ関数を 使用することになります

00:03:40.110 --> 00:03:43.385
そのため ノードの中に 明記しておくのが 得策です

00:03:43.384 --> 00:03:46.284
さきほど 見たとおり パーセプトロンの表記法は 2種類あります

00:03:46.284 --> 00:03:50.490
左側には 入力ノードから生じた バイアスユニットがあり 値は 1です

00:03:50.490 --> 00:03:54.370
右側では バイアスが ノードの中に 含まれています

