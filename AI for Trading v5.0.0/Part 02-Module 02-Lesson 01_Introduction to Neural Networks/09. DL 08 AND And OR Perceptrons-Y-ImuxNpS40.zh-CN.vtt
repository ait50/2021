WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.060
感知器有一个非常有趣的特征

00:00:03.060 --> 00:00:06.490
某些逻辑运算符可以表示为感知器

00:00:06.490 --> 00:00:11.250
例如 这是逻辑与运算 (AND) 它是如何进行的？

00:00:11.250 --> 00:00:15.554
AND 运算有两个输入和一个输出

00:00:15.554 --> 00:00:18.448
输入可以是真 (true) 或假 (false)

00:00:18.449 --> 00:00:21.835
但是仅当两个输入都是 true 时 输出才为 true

00:00:21.835 --> 00:00:26.219
例如 如果输入是 true 和 true 那么输出是 true

00:00:26.219 --> 00:00:31.065
如果输入是 true 和 false 那么输出是 false

00:00:31.065 --> 00:00:36.564
如果输入是 false 和 true 那么输出是 false

00:00:36.564 --> 00:00:42.090
最后 如果输入是 false 和 false 那么输出还是 false

00:00:42.090 --> 00:00:44.134
如何将这种运算转换为感知器呢？

00:00:44.134 --> 00:00:48.420
第一步是将这个 true/false 表变成 0/1 表

00:00:48.420 --> 00:00:54.395
1 对应 true 而 0 对应 false

00:00:54.395 --> 00:00:58.045
现在在这里画出感知器 和之前一样

00:00:58.045 --> 00:01:01.259
有一条由权重和偏差定义的直线

00:01:01.259 --> 00:01:05.203
有一个正区域 用蓝色表示 并有一个负区域 用红色表示

00:01:05.203 --> 00:01:07.183
这个感知器将画出每个点

00:01:07.185 --> 00:01:09.129
如果点落入正区域

00:01:09.129 --> 00:01:10.620
则返回 1

00:01:10.620 --> 00:01:14.599
如果落入负区域 则返回 0

00:01:14.599 --> 00:01:17.650
我们来试试

00:01:17.650 --> 00:01:21.390
1 1 落入正区域 所以感知器返回 1

00:01:21.390 --> 00:01:27.465
1 0 落入负区域 所以感知器返回 0

00:01:27.465 --> 00:01:34.319
0 1 落入负区域 所以感知器返回 0

00:01:34.319 --> 00:01:37.030
最后 0 0 也落入负区域

00:01:37.030 --> 00:01:41.730
所以感知器返回 0

00:01:41.730 --> 00:01:44.495
其他逻辑运算也可以转换为感知器

00:01:44.495 --> 00:01:46.750
例如 在逻辑或运算 (OR) 中

00:01:46.750 --> 00:01:50.280
如果两个输入中的任何一个为 true 则返回 true

00:01:50.280 --> 00:01:54.608
也就是这个表格 把它转换成这个感知器

00:01:54.608 --> 00:01:59.828
和之前的很相似 只是这条线具有不同的权重和偏差

00:01:59.828 --> 00:02:03.153
AND 和 OR 感知器的权重和偏差分别是多少？

00:02:03.155 --> 00:02:06.000
你可以在下面的测验中研究一下

