WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.600
下面说说我是如何定义给定索引的上下文字词的

00:00:04.600 --> 00:00:07.220
首先 根据之前从论文中摘录的一段文字

00:00:07.220 --> 00:00:10.230
我将定义范围 R

00:00:10.230 --> 00:00:13.980
R 是从 1 到 C 的一个随机整数，C 是窗口大小

00:00:13.980 --> 00:00:17.780
randint() 获取一个不包含最后一个数字的范围

00:00:17.780 --> 00:00:19.790
因此这里是 +1

00:00:19.790 --> 00:00:23.650
然后定义上下文窗口的 start 和 stop 索引

00:00:23.650 --> 00:00:26.060
start 是过去字词的范围

00:00:26.060 --> 00:00:29.580
等于目标字词的索引减去范围 R

00:00:29.580 --> 00:00:33.870
前提是索引不是负数

00:00:33.870 --> 00:00:36.800
如果这个运算的结果是负数

00:00:36.800 --> 00:00:41.060
那么将 start 索引设为字词列表的起始索引 0

00:00:41.060 --> 00:00:43.920
stop 索引是特征字词的结束位置

00:00:43.920 --> 00:00:45.985
即目标字词的索引

00:00:45.985 --> 00:00:47.875
加上范围 R

00:00:47.875 --> 00:00:52.375
最后 我不希望返回的上下文包含传入索引对应的字词

00:00:52.375 --> 00:00:55.070
因此将 target_words 定义为

00:00:55.070 --> 00:00:58.340
从 start 到 idx 的字词

00:00:58.340 --> 00:01:00.030
以及

00:01:00.030 --> 00:01:02.375
从 idx+1 到 stop+1 的字词

00:01:02.375 --> 00:01:04.760
然后以列表形式返回这些字词

00:01:04.760 --> 00:01:08.210
使用字词标记测试集测试这段代码

00:01:08.210 --> 00:01:09.950
并运行几次代码

00:01:09.950 --> 00:01:14.390
获得了传入索引 5 周围的几个字词

00:01:14.390 --> 00:01:17.455
可以看出 Target 不包含目标索引

00:01:17.455 --> 00:01:20.065
这一行数字是我创建的输入数据

00:01:20.065 --> 00:01:21.860
它们是从 0 到 9 的整数

00:01:21.860 --> 00:01:23.825
如果运行此单元格多次

00:01:23.825 --> 00:01:26.000
将会看到不同的上下文字词

00:01:26.000 --> 00:01:28.800
因为随机生成了不同的 R

00:01:28.800 --> 00:01:30.080
我在此函数下面

00:01:30.080 --> 00:01:32.030
定义了生成器函数

00:01:32.030 --> 00:01:35.630
此函数将利用我们刚刚定义的 get_target() 函数

00:01:35.630 --> 00:01:40.135
get_batches() 的输入参数是字词标记列表 批次大小和窗口大小

00:01:40.135 --> 00:01:42.740
它确保我们能创建完整的数据批次

00:01:42.740 --> 00:01:47.150
在这个 for 循环里 我会一次遍历一批数据

00:01:47.150 --> 00:01:51.435
获取一批数据 然后对这批数据里的每个字词都调用 get_target

00:01:51.435 --> 00:01:56.065
返回给定批次字词周围的窗口里的上下文字词

00:01:56.065 --> 00:02:01.115
在这里调用 extend() 使每批 x 和 y 都是一行值

00:02:01.115 --> 00:02:04.080
使 x 的长度与 y 一样

00:02:04.080 --> 00:02:09.620
最后 使用 yield 返回输入字词 x 和上下文字词 y 列表

00:02:09.620 --> 00:02:11.360
所以这是一个生成器函数

00:02:11.360 --> 00:02:12.615
在下面的单元格中

00:02:12.615 --> 00:02:14.510
我们将代码应用到虚拟数据上

00:02:14.510 --> 00:02:16.725
看看这个批次生成函数的效果如何

00:02:16.725 --> 00:02:21.180
对生成器函数调用 next() 并获得 x 和 y 批次数据

00:02:21.180 --> 00:02:23.175
在这里传入整数文本

00:02:23.175 --> 00:02:25.770
将批次大小设为 4 并将窗口大小设为 5

00:02:25.770 --> 00:02:27.095
运行此单元格

00:02:27.095 --> 00:02:31.425
输出看起来有点怪 因为数据都扩展成了一行

00:02:31.425 --> 00:02:34.085
但是可以看出我获得了期望的 4 个批次

00:02:34.085 --> 00:02:36.530
因为这里有四组不同的输入值 x

00:02:36.530 --> 00:02:38.550
分别是 0、1、2、3

00:02:38.550 --> 00:02:40.750
看看第一组输入 0

00:02:40.750 --> 00:02:42.230
发现长度是 3

00:02:42.230 --> 00:02:44.700
因此目标 y 的长度肯定也是 3

00:02:44.700 --> 00:02:47.330
相应的上下文是 1、2、3

00:02:47.330 --> 00:02:49.670
表示输入索引 0 周围的未来窗口中的所有上下文字词

00:02:49.670 --> 00:02:52.375
和我们预期的一样

00:02:52.375 --> 00:02:54.450
对于其他输入输出批次

00:02:54.450 --> 00:02:59.830
可以看出我生成了输入值 1、2 和 3 周围的上下文字词

00:02:59.830 --> 00:03:02.000
我们已经获得了批次输入数据

00:03:02.000 --> 00:03:03.640
以及上下文字词

00:03:03.640 --> 00:03:08.150
接下来我们将定义 Word2Vec 模型

00:03:08.150 --> 00:03:09.670
并用这些批次数据训练该模型

