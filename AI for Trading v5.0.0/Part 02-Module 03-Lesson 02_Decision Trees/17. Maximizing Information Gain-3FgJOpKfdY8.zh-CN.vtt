WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.015
现在 我们继续学习建立决策树

00:00:03.015 --> 00:00:04.860
我们的算法很简单

00:00:04.860 --> 00:00:07.650
浏览每列给出的可能的分法

00:00:07.650 --> 00:00:09.605
计算其信息增益

00:00:09.605 --> 00:00:11.335
并选择信息增益最大的分法

00:00:11.335 --> 00:00:14.740
现在 我们来计算父结点的熵 也就是这一列的数据

00:00:14.740 --> 00:00:17.574
我们将计算图标这一列的熵

00:00:17.574 --> 00:00:19.390
这里有三个 Pokemon Go

00:00:19.390 --> 00:00:21.865
两个 WhatsApp 和一个 Snapchat

00:00:21.864 --> 00:00:25.119
其熵为负六分之三

00:00:25.120 --> 00:00:27.595
乘底数为 2 真数为六分之三的对数函数

00:00:27.594 --> 00:00:28.869
减六分之二

00:00:28.870 --> 00:00:30.429
乘底数为 2 真数为六分之二的对数函数

00:00:30.429 --> 00:00:31.660
minus one over six,
减六分之一

00:00:31.660 --> 00:00:33.625
乘底数为 2 真数为六分之一的对数函数

00:00:33.625 --> 00:00:36.700
结果为 1.46

00:00:36.700 --> 00:00:38.478
现在 如果我们将其按性别划分

00:00:38.478 --> 00:00:39.865
we get two sets,
将得到两个集合

00:00:39.865 --> 00:00:43.344
一个包含一个 Pokemon Go 和两个 WhatsApp

00:00:43.344 --> 00:00:46.174
另一个包含一个 Snapchat 和两个 Pokemon Go

00:00:46.174 --> 00:00:50.174
这两个集合的熵均为 0.92

00:00:50.174 --> 00:00:55.829
因此子结点熵的平均值也为 0.92

00:00:55.829 --> 00:01:00.089
信息增益为 1.46 减 0.92

00:01:00.090 --> 00:01:01.845
为 0.54

00:01:01.844 --> 00:01:03.884
如果我们按照职业分

00:01:03.884 --> 00:01:06.254
一个集合中包含三个 Pokemon Go

00:01:06.254 --> 00:01:09.269
另一个集合包含两个 WhatsApps 和一个 Snapchat

00:01:09.269 --> 00:01:12.000
第一个集合的熵为 0

00:01:12.000 --> 00:01:15.180
第二个集合的熵为 0.92

00:01:15.180 --> 00:01:17.940
因此子结点熵的平均值为 0.46

00:01:17.939 --> 00:01:23.054
其信息增益为 1.46 减 0.46 即 1

00:01:23.055 --> 00:01:28.065
总结可得 按性别分的信息增益为 0.54

00:01:28.064 --> 00:01:31.664
按职业分的信息增益为 1

00:01:31.665 --> 00:01:33.780
按照算法 选择信息增益大的

00:01:33.780 --> 00:01:36.719
即为按职业分类

00:01:36.719 --> 00:01:40.185
按职业分将得到两个集合

00:01:40.185 --> 00:01:41.640
第一个集合很棒

00:01:41.640 --> 00:01:43.844
因为每个人都下载 Pokemon Go

00:01:43.844 --> 00:01:46.304
对于第二个集合 我们可以再次优化

00:01:46.305 --> 00:01:49.050
我们可以将第二个集合按性别再分

00:01:49.049 --> 00:01:51.179
之后 两个集合的结果都很棒

00:01:51.180 --> 00:01:53.145
其中一个集合中 每个人都下载 WhatsApp

00:01:53.144 --> 00:01:55.754
另一个集合中 每个人都下载 Snapchat

00:01:55.754 --> 00:01:58.189
现在 我们的决策树就完成了

00:01:58.189 --> 00:01:59.679
如果我们想利用连续特征而非离散特征

00:01:59.680 --> 00:02:02.740
我们还可以继续进行

00:02:02.739 --> 00:02:04.359
首先想一下其中的细节

00:02:04.359 --> 00:02:09.390
最根本的 是要想清楚所有可能的水平切法和垂直分法

00:02:09.390 --> 00:02:13.013
看看哪种分法的熵最大

00:02:13.014 --> 00:02:17.080
然后在建立决策树时反复迭代

00:02:17.080 --> 00:02:20.560
这里我们可以看到 我们的垂直切线在横坐标 5 处

00:02:20.560 --> 00:02:25.134
水平切线在纵坐标 7 处

00:02:25.134 --> 00:02:30.250
最后一道水平切线在纵坐标 2 处

00:02:30.250 --> 00:02:34.270
最终就得到了有两部分数据的决策树

