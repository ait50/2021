WEBVTT
Kind: captions
Language: zh-CN

00:00:00.160 --> 00:00:03.230
我已经向你介绍了 k-均值 聚类方法的理论知识

00:00:03.230 --> 00:00:07.500
现在 我将向你展示如何使用 scikit-learn 的实现

00:00:07.500 --> 00:00:08.780
将它部署到你自己的研究中

00:00:08.780 --> 00:00:10.340
我先通过 Google 搜索开始

00:00:10.340 --> 00:00:13.810
发现有关 scikit-learn 聚类方法的内容有一整页

00:00:13.810 --> 00:00:15.890
进入该页面后 我首先注意到

00:00:15.890 --> 00:00:20.020
除了 k-均值 聚类外 还有许多类型的聚类

00:00:20.020 --> 00:00:23.510
此处所有不同的列都是不同类型的聚类

00:00:23.510 --> 00:00:27.720
我们不用全都了解 而只是使用该页面导航至 k-均值 文档

00:00:27.720 --> 00:00:30.620
从而使你能够更好地

00:00:30.620 --> 00:00:32.509
了解 scikit-learn 的处理方法

00:00:32.509 --> 00:00:35.540
此为我拥有的所有不同聚类方法的列表

00:00:35.540 --> 00:00:39.320
在这里 列表的第一项就是 k-均值

00:00:39.320 --> 00:00:41.350
以及某些有关该算法的摘要信息

00:00:41.350 --> 00:00:43.725
你要针对 k-均值 定义的参数之一就是

00:00:43.725 --> 00:00:45.760
聚类的数量

00:00:45.760 --> 00:00:50.330
请注意 我们必须在一开始就表明要查找的聚类数

00:00:50.330 --> 00:00:53.225
确定要尝试的聚类数是

00:00:53.225 --> 00:00:55.870
使用 k-均值 时最具挑战的工作之一

00:00:57.170 --> 00:01:00.220
然后他会向我们提供一些有关可扩展性的信息

00:01:00.220 --> 00:01:02.700
这大体上会告诉我们 当开始拥有大量数据或聚类时

00:01:02.700 --> 00:01:04.928
该算法是如何运行的

00:01:04.928 --> 00:01:08.390
使用案例为我们提供些许信息

00:01:08.390 --> 00:01:11.710
比如当你的聚类中点的数量比较平均时

00:01:11.710 --> 00:01:13.510
这有利于用于一般用途等

00:01:13.510 --> 00:01:16.660
最后 k-均值 聚类的工作原理是基于

00:01:16.660 --> 00:01:18.480
各点之间的距离

00:01:18.480 --> 00:01:21.720
与我们迄今为止看到的内容都很协调

00:01:21.720 --> 00:01:23.320
我们再深入一点

00:01:23.320 --> 00:01:25.790
现在 我们是在 k-均值 文档页面上

00:01:25.790 --> 00:01:28.460
有三个参数我希望你能够

00:01:28.460 --> 00:01:29.470
特别重视

00:01:29.470 --> 00:01:32.410
第一个 也是最重要的一个是 n_clusters

00:01:32.410 --> 00:01:35.270
n_clusters 的默认值是 8

00:01:35.270 --> 00:01:38.970
当然 大家都知道算法中的聚类数量是

00:01:38.970 --> 00:01:42.790
你根据实际的情况自行设置的值

00:01:42.790 --> 00:01:45.260
它甚至可能需要你反复调整

00:01:45.260 --> 00:01:47.560
所以 你应该随时考虑是否真的想要使用该默认值

00:01:47.560 --> 00:01:50.910
或者是否要将其更改为其他值

00:01:50.910 --> 00:01:53.170
我向你保证 你大部分情况下都想将其

00:01:53.170 --> 00:01:54.320
更改为其他值

00:01:54.320 --> 00:01:57.990
我希望你注意的第二个参数是 max_iter=300

00:01:57.990 --> 00:02:01.620
请注意 当我们运行 k-均值 聚类时

00:02:01.620 --> 00:02:05.320
我们要在查找聚类时进行迭代

00:02:05.320 --> 00:02:10.500
将各个点分配到矩心 然后移动矩心

00:02:10.500 --> 00:02:12.090
然后重新分配这些点

00:02:12.090 --> 00:02:13.770
重新移动矩心

00:02:13.770 --> 00:02:17.020
每一次进行分配和移动

00:02:17.020 --> 00:02:20.078
分配和移动的步骤就是对算法的迭代

00:02:20.078 --> 00:02:23.660
max_iter 其实就是表明你希望进行

00:02:23.660 --> 00:02:25.995
多少次算法迭代

00:02:25.995 --> 00:02:29.440
300 对你来说通常是比较合理的值

00:02:29.440 --> 00:02:32.120
实际上 我想大部分情况下

00:02:32.120 --> 00:02:35.700
算法都会在达到最大值前就已经终结了

00:02:35.700 --> 00:02:38.690
但如果你希望更好地控制算法以及

00:02:38.690 --> 00:02:41.680
迭代流程执行的次数

00:02:41.680 --> 00:02:42.520
这正是你需要的参数

00:02:42.520 --> 00:02:45.280
我要提到的最后一个参数是

00:02:45.280 --> 00:02:46.840
另一个参数 但非常重要

00:02:46.840 --> 00:02:50.240
那就是你提供的不同初始化的数量

00:02:50.240 --> 00:02:53.240
还记得我们说过 k-均值 聚类有一个挑战

00:02:53.240 --> 00:02:55.800
就是完全取决于初始状况

00:02:55.800 --> 00:02:58.220
你有时最终会得到不同的聚类结果

00:02:58.220 --> 00:03:01.320
然后你需要多次重复该算法

00:03:01.320 --> 00:03:05.250
这样 即使任意这些聚类可能都不对 但总的来说

00:03:05.250 --> 00:03:08.850
所有聚类的集合总会有满足你要求的聚类

00:03:08.850 --> 00:03:10.320
这就是该参数控制的对象

00:03:10.320 --> 00:03:13.470
基本上就是控制算法初始化的次数

00:03:13.470 --> 00:03:16.320
提出聚类的次数

00:03:16.320 --> 00:03:19.360
你会发现默认情况下是进行十次

00:03:19.360 --> 00:03:23.750
如果你出于某种原因认为你的聚类可能

00:03:23.750 --> 00:03:25.050
特别容易出现糟糕或艰难的初始化过程

00:03:25.050 --> 00:03:29.910
那么你需要改的参数就在这里

00:03:29.910 --> 00:03:33.570
可能你需要将初始化次数提高一些

00:03:33.570 --> 00:03:36.400
但再次强调一遍 在所有这些参数中

00:03:36.400 --> 00:03:39.580
聚类数量是绝对最为重要的参数

00:03:39.580 --> 00:03:41.610
你应该认真对待

00:03:41.610 --> 00:03:43.570
并反复测试后再决定

