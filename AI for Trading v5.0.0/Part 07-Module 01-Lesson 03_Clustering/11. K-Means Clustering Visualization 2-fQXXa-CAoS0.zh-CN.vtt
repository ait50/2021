WEBVTT
Kind: captions
Language: zh-CN

00:00:00.380 --> 00:00:03.210
一旦开始分配中心点 这些彩色区域中会立即显示的信息就是

00:00:03.210 --> 00:00:07.200
所有这些点将如何与其中一个中心点关联

00:00:07.200 --> 00:00:10.790
如何与其中一个聚类关联

00:00:10.790 --> 00:00:14.120
你会发现蓝色区域的形状可能已经相当不错

00:00:15.140 --> 00:00:18.060
我感觉我们放置初始矩心的位置不错

00:00:18.060 --> 00:00:19.760
其中有运气成分

00:00:19.760 --> 00:00:22.950
它的位置好像与这一块数据的中心比较近

00:00:22.950 --> 00:00:25.960
与红色和绿色相搭配 它们看起来好像在同一聚类中

00:00:25.960 --> 00:00:28.680
相互堆叠一样

00:00:28.680 --> 00:00:32.580
K-means 会开始对该情况进行整理 并使所有聚类合理分配

00:00:32.580 --> 00:00:34.690
我们拭目以待

00:00:34.690 --> 00:00:36.080
接下来 我会点击“开始”

00:00:36.080 --> 00:00:40.210
首先 它会明确地告诉我

00:00:40.210 --> 00:00:41.720
各个点被分配到哪个聚类

00:00:41.720 --> 00:00:44.940
你看 这里有几个蓝色的点被分配到错误的聚类中

00:00:44.940 --> 00:00:47.150
然后会分配红色和绿色的点

00:00:47.150 --> 00:00:51.170
这是关联步骤

00:00:51.170 --> 00:00:52.850
会将所有的点与最近的矩心建立关联

00:00:52.850 --> 00:00:55.480
然后 我们要做的是更新矩心

00:00:55.480 --> 00:00:59.440
现在 要将矩心移至

00:00:59.440 --> 00:01:02.570
所有关联的点的平均值处

00:01:02.570 --> 00:01:05.519
我们在这里的点太多了

00:01:05.519 --> 00:01:08.850
因此 我特别希望这个绿色的点能够向右移动

00:01:08.850 --> 00:01:10.030
我们更新一下

00:01:10.030 --> 00:01:11.590
现在这样看起来好多了

00:01:11.590 --> 00:01:13.120
如果我们一切保持原样

00:01:13.120 --> 00:01:15.920
你也知道之前聚类是什么样

00:01:15.920 --> 00:01:20.210
而如今 所有这些以前绿色的点都变为红色

00:01:20.210 --> 00:01:22.090
这里蓝色的点也是如此

00:01:22.090 --> 00:01:26.360
你会发现 一个步骤就能对最初糟糕的状况产生多大的影响

00:01:26.360 --> 00:01:29.460
我们已经开始能够很好地掌控数据的结构

00:01:29.460 --> 00:01:31.030
现在我要重新分配这些点

00:01:31.030 --> 00:01:34.590
通过进行迭代 重新将各个点分配到最近的矩心

00:01:34.590 --> 00:01:37.080
现在一切看起来都协调多了

00:01:37.080 --> 00:01:38.700
可能只需要一次或两次迭代

00:01:38.700 --> 00:01:41.900
就可以使矩心位于聚类的中心位置

00:01:41.900 --> 00:01:45.840
因此 我更新并重新分配这些点

00:01:45.840 --> 00:01:47.810
所有点的位置都没变

00:01:47.810 --> 00:01:51.070
因此 这就是 k-均值 聚类要分配的最终聚类

00:01:51.070 --> 00:01:54.310
利用该算法 只需三到四步 我就可以将所有点分配到聚类中

00:01:54.310 --> 00:01:57.410
而且在这个例子中很美妙地完成了聚类

