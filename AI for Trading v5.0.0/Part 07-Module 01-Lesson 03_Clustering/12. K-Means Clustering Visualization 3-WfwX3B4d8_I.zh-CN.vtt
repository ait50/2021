WEBVTT
Kind: captions
Language: zh-CN

00:00:00.100 --> 00:00:02.840
现在 我将向你展示另一个效果并不完美的数据集

00:00:02.840 --> 00:00:06.580
你可以了解 k-均值 聚类是如何保持不变的

00:00:06.580 --> 00:00:10.100
我将在该示例中使用的数据类型为均匀分布

00:00:10.100 --> 00:00:11.690
这是均匀分布的样子

00:00:11.690 --> 00:00:13.430
这些点四处分布

00:00:13.430 --> 00:00:16.810
看到这些点 我不会说 这儿有我要选择的明确聚类

00:00:16.810 --> 00:00:21.000
但我仍希望这样描述

00:00:21.000 --> 00:00:24.700
这里的这些点比那里的那些点彼此更为相似

00:00:24.700 --> 00:00:28.430
k-means 聚类方法是可用于从数学方面

00:00:28.430 --> 00:00:29.710
描述数据呈现出该现象的方法之一

00:00:29.710 --> 00:00:33.660
我并不能仅凭理论就确定我要在此使用的矩心的数量

00:00:33.660 --> 00:00:35.400
所以我只使用两个

00:00:35.400 --> 00:00:37.200
这个数字还算合理

00:00:37.200 --> 00:00:38.040
一 二

00:00:38.040 --> 00:00:40.390
然后 我们来了解一下在该案例中会出现什么情况

00:00:40.390 --> 00:00:41.950
很少的点需要重新分配

00:00:41.950 --> 00:00:42.740
移动矩心

00:00:42.740 --> 00:00:46.780
你会看到此处需要进行更多微调

00:00:46.780 --> 00:00:52.560
但最终基本上都是沿着该轴分割数据

00:00:52.560 --> 00:00:56.930
如果你再次尝试 根据确定的初始状况和

00:00:56.930 --> 00:00:59.470
这些点分配方式的详情

00:00:59.470 --> 00:01:02.080
我会得到略有不同的结果

00:01:02.080 --> 00:01:02.980
你也看到了

00:01:02.980 --> 00:01:05.519
我最终是垂直而不是水平分割这些数据

00:01:05.519 --> 00:01:08.360
对此 你的想法应该是 矩心初始放置的位置通常比较随机

00:01:08.360 --> 00:01:13.360
而且非常重要

00:01:13.360 --> 00:01:16.410
因此根据某一确定的初始状况

00:01:16.410 --> 00:01:20.770
你最终可以使聚类的结果看起来完全不同

00:01:20.770 --> 00:01:22.750
现在 这看起来可能是一个比较严重的问题

00:01:22.750 --> 00:01:26.150
但我们有一种相当强大的方法将其解决

00:01:26.150 --> 00:01:27.020
接下来我们讨论一下该方法

