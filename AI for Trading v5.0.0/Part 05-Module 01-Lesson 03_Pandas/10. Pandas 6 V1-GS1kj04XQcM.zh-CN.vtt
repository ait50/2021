WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.378
在开始分析数据或用数据训练学习算法之前

00:00:05.378 --> 00:00:06.824
我们需要清理数据

00:00:06.825 --> 00:00:11.230
也就是说我们要想办法检测并修正数据里的错误

00:00:11.230 --> 00:00:14.205
数据集的劣质数据有很多种

00:00:14.205 --> 00:00:17.780
比如异常值或错误值

00:00:17.780 --> 00:00:22.960
但最常见的是缺失值

00:00:22.960 --> 00:00:24.545
我们之间就说过

00:00:24.545 --> 00:00:26.865
Pandas 会将 NaN

00:00:26.864 --> 00:00:29.179
赋给缺失数据 表示此处非数字

00:00:29.179 --> 00:00:34.259
本节将讲解检测并处理这些 NaN 值的方法

00:00:34.259 --> 00:00:37.354
在这个 DataFrame 中 我们有三个 NaN 值

00:00:37.354 --> 00:00:39.354
一个在 store 1

00:00:39.354 --> 00:00:41.719
两个在 store 3

00:00:41.719 --> 00:00:44.089
但如果我们往 DataFrame 加载的数据集太庞大

00:00:44.090 --> 00:00:49.230
比如加载了数百万个项

00:00:49.229 --> 00:00:53.819
那 NaN 值的数目就没这么一目了然了

00:00:53.820 --> 00:00:56.909
这种时候 我们可以结合多个方法

00:00:56.909 --> 00:01:00.049
对数据里的 NaN 值数量进行统计

00:01:00.049 --> 00:01:03.919
要用到的方法有 isnull 和 sum

00:01:03.920 --> 00:01:07.935
结合使用这两个方法 就能统计 DataFrame 里 NaN 值的数目了 我们一步一步来

00:01:07.935 --> 00:01:10.859
方法 isnull 会返回一个 DataFrame 

00:01:10.859 --> 00:01:14.385
将 DataFrame store_items 的每个值替换成布尔值

00:01:14.385 --> 00:01:16.500
如果值为 NaN 布尔值就为真

00:01:16.500 --> 00:01:20.780
在 Pandas 中 数字 1 表示逻辑真值

00:01:20.780 --> 00:01:25.640
数字 0 表示逻辑假值

00:01:25.640 --> 00:01:29.049
因此 要知道 NaN 值的数量

00:01:29.049 --> 00:01:32.609
只需统计 DataFrame 里逻辑真值的数量即可

00:01:32.609 --> 00:01:36.900
用方法 sum 来统计 1 的数量 就可以知道每一列有多少个 NaN 值了

00:01:36.900 --> 00:01:42.055
再调用一次方法 sum 统计整个 DataFrame NaN 值的数量

00:01:42.055 --> 00:01:44.905
我们也可以不统计 NaN 值的数量

00:01:44.905 --> 00:01:51.085
反其道而行 用方法 count 来统计非 NaN 值的数量

00:01:51.084 --> 00:01:55.449
知道了怎么找出数据集里的 NaN 值

00:01:55.450 --> 00:01:58.469
下一步就是决定怎么处理这些值了

00:01:58.469 --> 00:02:00.734
总地来说 我们有两个选择

00:02:00.734 --> 00:02:04.140
删除或替换

00:02:04.140 --> 00:02:07.424
要删除缺失值 可以用方法 dropna

00:02:07.424 --> 00:02:14.090
我们可以设参数 axis 为 0 删除任何有 NaN 值的行

00:02:14.090 --> 00:02:19.465
也可以设 axis 为 1 删除任何有 NaN 值的列

00:02:19.465 --> 00:02:23.909
方法 dropna 是在其它地方删除行和列的

00:02:23.909 --> 00:02:27.025
也就是说 原 DataFrame 不会出现改动

00:02:27.025 --> 00:02:32.275
像这样把关键字 inplace 设为 True 你就可以在原 DataFrame 上删除行和列了

00:02:32.275 --> 00:02:35.270
现在我们不删除 NaN 值了

00:02:35.270 --> 00:02:37.960
而是用具体数值来替换这些值

00:02:37.960 --> 00:02:43.155
我们可以把所有 NaN 值替换成 0

00:02:43.155 --> 00:02:46.164
为此 我们可以用方法 fillna

00:02:46.164 --> 00:02:49.469
我们也可以用前向填充 ffill

00:02:49.469 --> 00:02:53.859
以上一行或列的值来替换 NaN 值

00:02:53.860 --> 00:03:00.265
该方法会用给定轴上的前一个值来填充相应的 NaN 值

00:03:00.264 --> 00:03:02.254
这是原始 DataFrame 

00:03:02.254 --> 00:03:05.500
注意 store 3 的两个 NaN 值

00:03:05.500 --> 00:03:09.354
已经被同一列的前值替换掉了

00:03:09.354 --> 00:03:14.375
但 store 1 里的 NaN 值并没有得到替换

00:03:14.375 --> 00:03:17.129
因为这一列没有前值

00:03:17.129 --> 00:03:20.805
NaN 是这一列的第一个值

00:03:20.805 --> 00:03:26.580
如果我们用前一行的值来进行前向填充 这种事就不会发生

00:03:26.580 --> 00:03:28.200
我们可以看到

00:03:28.199 --> 00:03:32.804
此时所有 NaN 值都替换成了同一行的前一个值

00:03:32.805 --> 00:03:35.200
同理 你也可以

00:03:35.199 --> 00:03:39.199
用 DataFrame 里的后一个值来填充相应的 NaN 值

00:03:39.199 --> 00:03:41.869
这个过程叫做后向填充

00:03:41.870 --> 00:03:45.900
可以把 NaN 值替换成与其同列的后一个值

00:03:45.900 --> 00:03:51.360
store 1 里的 NaN 值已经替换成同列的后一个值了

00:03:51.360 --> 00:03:53.850
但是 store 3 里的两个 NaN 值得不到替换

00:03:53.849 --> 00:03:57.525
因为它们是列里的最后一个值

00:03:57.525 --> 00:04:01.170
方法 fillna 不会在原 DataFrame 里填充 NaN 值

00:04:01.169 --> 00:04:06.444
所以如果想修改原 DataFrame 请把参数 inplace 设为 True

00:04:06.444 --> 00:04:11.560
我们还可以用多种插值方法来替换 NaN 值

00:04:11.560 --> 00:04:15.250
比如 这里用了线性插值

00:04:15.250 --> 00:04:19.129
借助同轴 (列) 的值来替换 NaN 值

00:04:19.129 --> 00:04:25.129
store 3 里的两个 NaN 值因而替换成了相应的线性插值

00:04:25.129 --> 00:04:29.740
但 store 1 的 NaN 值得不到替换

00:04:29.740 --> 00:04:34.530
因为前面没有数据 插值函数无法算出替换值

00:04:34.529 --> 00:04:39.964
线性插值时 我们也可以像这样用同行的值来替换 NaN 值

00:04:39.964 --> 00:04:41.679
就像其它方法一样

00:04:41.680 --> 00:04:45.600
插值方法不会在原 DataFrame 上替换 NaN 值

