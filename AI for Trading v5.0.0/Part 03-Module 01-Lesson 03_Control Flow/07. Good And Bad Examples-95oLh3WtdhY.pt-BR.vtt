WEBVTT
Kind: captions
Language: pt-BR

00:00:00.734 --> 00:00:03.901
BOOLEANAS PARA CONDIÇÕES:
BONS E MAUS EXEMPLOS

00:00:03.934 --> 00:00:06.634
Veremos bons e maus exemplos

00:00:06.701 --> 00:00:10.400
de expressões booleanas
usadas em instruções "if".

00:00:10.434 --> 00:00:13.400
Embora "true"
seja uma booleana válida,

00:00:13.434 --> 00:00:16.033
não funciona como condição,

00:00:16.100 --> 00:00:18.734
já que sempre avalia
como verdadeiro,

00:00:18.801 --> 00:00:21.734
e o código indentado
é sempre executado.

00:00:21.768 --> 00:00:22.900
Da mesma forma,

00:00:22.934 --> 00:00:26.033
"if false" também não é
uma condição desejável.

00:00:26.100 --> 00:00:29.901
A condição e a instrução "if"
jamais aconteceriam.

00:00:29.934 --> 00:00:33.434
Neste exemplo,
"is_cold" ou "not is_cold"

00:00:33.501 --> 00:00:36.200
sempre avaliará
como verdadeiro.

00:00:36.234 --> 00:00:39.400
Se estiver gelado,
"is_cold" será verdadeiro.

00:00:39.434 --> 00:00:42.834
Se não estiver,
"not is_cold" será verdadeiro.

00:00:42.901 --> 00:00:44.701
Isto não serve
como condição,

00:00:44.734 --> 00:00:48.501
pois o código indentado
sempre será executado.

00:00:48.534 --> 00:00:52.901
Este código é válido em Python,
mas não é uma booleana,

00:00:52.934 --> 00:00:54.901
embora pareça uma.

00:00:54.934 --> 00:00:58.234
O motivo é que a expressão
à direita do "or"

00:00:58.300 --> 00:01:01.734
não é uma expressão booleana,
mas uma string.

00:01:01.801 --> 00:01:04.033
Mais adiante,
discutiremos o que acontece

00:01:04.100 --> 00:01:06.701
quando usamos um objeto
de tipo não booleano

00:01:06.734 --> 00:01:08.300
em vez de booleanos.

00:01:09.033 --> 00:01:10.901
Exige mais caracteres,

00:01:10.934 --> 00:01:14.434
mas agora esta expressão
é inequivocamente booleana.

00:01:14.501 --> 00:01:18.601
As expressões dos dois lados
do operador lógico "or"

00:01:18.634 --> 00:01:21.000
verificam alguma coisa.

00:01:21.033 --> 00:01:23.200
Essa é uma condição válida,

00:01:23.234 --> 00:01:26.801
mas poderíamos expressá-la
mais sucinta e claramente.

00:01:26.834 --> 00:01:30.234
"is_cold"
é uma booleana em si,

00:01:30.300 --> 00:01:32.334
então podemos tornar o código
mais legível

00:01:32.400 --> 00:01:35.734
usando a variável em si
no lugar.

00:01:35.801 --> 00:01:38.634
Se você quer verificar
se uma booleana é falsa,

00:01:38.701 --> 00:01:40.834
use o operador "not".

00:01:41.934 --> 00:01:45.133
Vamos fazer um balanço das lições
aprendias com os exemplos.

00:01:45.200 --> 00:01:48.100
"True" e "false"
são booleanos,

00:01:48.133 --> 00:01:52.200
mas não faz sentido usar
"if true" ou "if false".

00:01:52.234 --> 00:01:55.801
Operadores lógicos
"and", "or" e "not"

00:01:55.834 --> 00:01:58.501
têm significados específicos,
que não correspondem

00:01:58.534 --> 00:02:01.000
às suas definições em inglês.

00:02:01.033 --> 00:02:04.234
Certifique-se de que suas booleanas
estão sendo verificadas

00:02:04.300 --> 00:02:06.501
da forma que você espera.

00:02:06.534 --> 00:02:08.901
Não compare
uma variável booleana

00:02:08.934 --> 00:02:11.834
com "== true" ou "== false".

00:02:11.901 --> 00:02:13.834
Essa comparação
não é necessária,

00:02:13.901 --> 00:02:17.300
já que a variável em si
é uma expressão booleana.

