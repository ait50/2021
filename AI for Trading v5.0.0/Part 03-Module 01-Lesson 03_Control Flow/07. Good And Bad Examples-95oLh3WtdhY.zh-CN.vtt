WEBVTT
Kind: captions
Language: zh-CN

00:00:03.209 --> 00:00:10.134
我们将介绍在 if 语句中使用的一些正反面布尔表达式示例

00:00:10.134 --> 00:00:13.594
虽然 True 是一个有效的布尔表达式

00:00:13.595 --> 00:00:18.769
但是并非是有用的条件 因为它始终为 true

00:00:18.769 --> 00:00:21.589
因此缩进的代码将始终运行

00:00:21.589 --> 00:00:25.975
同样 也不应该运行 if false 条件

00:00:25.975 --> 00:00:29.460
该条件和 if 语句将始终不会发生

00:00:29.460 --> 00:00:33.524
在此示例中

00:00:33.524 --> 00:00:35.939
is_cold 或 not is_cold 将始终为 true

00:00:35.939 --> 00:00:39.339
如果很冷 则 is_cold 将为 true

00:00:39.340 --> 00:00:43.095
如果不冷 则 not is_code 将为 true

00:00:43.094 --> 00:00:48.034
这个条件根本没用 因为缩进的代码段将始终运行

00:00:48.034 --> 00:00:50.859
这段代码是有效的 Python 代码

00:00:50.859 --> 00:00:52.975
但它不是布尔表达式

00:00:52.975 --> 00:00:55.109
虽然读起来像布尔表达式

00:00:55.109 --> 00:00:57.670
因为 or 右侧的表达式不是布尔表达式

00:00:57.670 --> 00:01:01.505
而是字符串

00:01:01.505 --> 00:01:04.859
稍后 我们将讨论用非布尔型对象

00:01:04.859 --> 00:01:09.164
代替布尔型对象 会发生什么

00:01:09.165 --> 00:01:11.030
多了几个字符

00:01:11.030 --> 00:01:14.695
但现在毫无疑问是布尔表达式

00:01:14.694 --> 00:01:21.199
逻辑运算符 or 两侧的表达式都在检查某个条件

00:01:21.200 --> 00:01:23.269
这是有效的条件

00:01:23.269 --> 00:01:26.589
但是我们可以表达得更清晰简练

00:01:26.590 --> 00:01:30.170
is_cold 本身是布尔表达式

00:01:30.170 --> 00:01:35.525
因此我们可以使用变量本身 使代码更容易读懂

00:01:35.525 --> 00:01:38.705
如果你想检查布尔值是否为 false

00:01:38.704 --> 00:01:41.310
可以使用运算符 not

00:01:41.310 --> 00:01:45.370
我们从这些示例中总结一些经验

00:01:45.370 --> 00:01:48.060
True 和 False 都是布尔值

00:01:48.060 --> 00:01:52.000
但是不能使用 if True 或 if False

00:01:52.000 --> 00:01:54.969
逻辑运算符 and or 

00:01:54.969 --> 00:01:57.519
和 not 的含义

00:01:57.519 --> 00:02:01.239
与字面上的英文含义不太一样

00:02:01.239 --> 00:02:06.569
确保布尔表达式按照你期望的方式进行评估

00:02:06.569 --> 00:02:12.129
请勿将布尔变量与 true 或 false 进行比较

00:02:12.129 --> 00:02:17.069
这么比较没意义 因为变量本身是布尔表达式

