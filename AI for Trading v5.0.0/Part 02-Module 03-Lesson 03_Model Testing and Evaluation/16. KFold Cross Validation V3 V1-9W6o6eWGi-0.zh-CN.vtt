WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.370
作为最后一部分 我们将学习一种可以循环利用数据的

00:00:02.370 --> 00:00:05.835
很有用的方法   叫K折交叉验证

00:00:05.835 --> 00:00:08.669
正如我们所知的 测试是通过把数据

00:00:08.669 --> 00:00:11.278
拆分两个集合来完成的  一个是训练集 另一个是测试集

00:00:11.278 --> 00:00:13.948
但是 这并不总是最合适的 因为我们会错过一些

00:00:13.948 --> 00:00:16.980
对训练模型有用的数据

00:00:16.980 --> 00:00:19.910
我们有什么办法不错过这些数据

00:00:19.910 --> 00:00:21.789
同时又不作弊吗？

00:00:21.789 --> 00:00:26.399
这里有个解决方案 这正是K折交叉验证发挥作用的时候

00:00:26.399 --> 00:00:30.750
K折交叉验证要做的是将数据分成K份

00:00:30.750 --> 00:00:32.685
在这个例子中  K是4

00:00:32.685 --> 00:00:35.804
然后 我们训练我们的模型K次

00:00:35.804 --> 00:00:39.269
每次轮流取不同的几份数据作为测试集

00:00:39.270 --> 00:00:42.710
把剩余数据作为训练集

00:00:42.710 --> 00:00:45.958
然后 我们对结果取平均 得到最终的模型

00:00:46.158 --> 00:00:49.113
从SKLearn库中调用K折交叉验证很简单

00:00:49.115 --> 00:00:52.579
我们要做的是创建一个K折交叉验证对象

00:00:52.579 --> 00:00:56.088
其参数分别是数据的大小和测试集的大小

00:00:56.090 --> 00:01:00.348
建议每次都随机化数据 以消除任何偏差暗示

00:01:00.548 --> 00:01:02.765
在这里 我们仍将数据分成若干份

00:01:02.765 --> 00:01:05.599
但现在这些数据是随机的而不是有序的

00:01:05.599 --> 00:01:08.780
用SKLearn库初始化K-fold对象时

00:01:08.780 --> 00:01:13.780
通过将SKLearn参数设置为True很容易实现随机化

