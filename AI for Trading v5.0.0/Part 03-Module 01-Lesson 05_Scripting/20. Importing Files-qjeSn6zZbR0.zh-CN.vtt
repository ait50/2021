WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.029
除了读取文件中的数据之外

00:00:03.029 --> 00:00:07.134
我们还可以导入其他脚本中的 Python 代码

00:00:07.134 --> 00:00:11.849
如果你处理的是大型项目 希望将代码整理成多个文件

00:00:11.849 --> 00:00:17.339
并重复利用这些文件中的代码 则能够导入其他脚本中的 Python 代码会非常方便

00:00:17.339 --> 00:00:22.170
如果你要导入的 Python 脚本与当前脚本位于同一个目录中

00:00:22.170 --> 00:00:23.910
只需输入 import

00:00:23.910 --> 00:00:28.054
然后输入文件名 无需添加 .py 扩展名

00:00:28.054 --> 00:00:31.679
导入语句写在 Python 脚本的顶部

00:00:31.679 --> 00:00:33.659
每个导入语句各占一行

00:00:33.659 --> 00:00:38.349
如果将导入语句放在脚本的后面 Python 依然会运行

00:00:38.350 --> 00:00:41.920
但是常规做法是始终将这些导入语句放在顶部

00:00:41.920 --> 00:00:46.050
你只能在导入语句之后访问所导入的内容

00:00:46.049 --> 00:00:48.864
因此首先添加这些导入语句不会让人困惑

00:00:48.865 --> 00:00:51.240
并且使读者能够在阅读代码的剩余部分之前

00:00:51.240 --> 00:00:54.195
先了解脚本依赖于哪些其他脚本

00:00:54.195 --> 00:00:56.905
我们先从一个很简单的示例开始

00:00:56.905 --> 00:01:03.439
这是一个叫做 other_script.py 的 Python 文件 它会输出 2+3

00:01:03.439 --> 00:01:05.569
我在这个 demo.py 文件中

00:01:05.569 --> 00:01:09.114
导入了 other_script 然后输出 4

00:01:09.114 --> 00:01:11.824
当我们运行 demo.py 时

00:01:11.825 --> 00:01:17.890
这个导入语句告诉 Python 运行该文件中的代码 该文件会输出 5

00:01:17.890 --> 00:01:22.049
然后继续执行该文件中的剩余代码 并输出 4

00:01:22.049 --> 00:01:26.950
如果这个文件的代码是 num = 2 + 3

00:01:26.950 --> 00:01:30.625
我们尝试在 demo.py 中访问该文件

00:01:30.625 --> 00:01:35.373
直接用变量名引用它将返回错误

00:01:35.373 --> 00:01:38.469
要访问 other_script.py 中的对象

00:01:38.469 --> 00:01:41.980
我们需要输入文件名 然后是点

00:01:41.980 --> 00:01:45.040
接着是要访问的对象

00:01:45.040 --> 00:01:48.475
告诉 Python 在导入的 other_script 文件中查找该对象

00:01:48.474 --> 00:01:51.429
现在成功地访问了该变量

00:01:51.430 --> 00:01:53.375
当 Python 运行该脚本时

00:01:53.375 --> 00:01:57.283
它只能直接访问在该脚本中定义的对象

00:01:57.283 --> 00:02:00.260
其中一个对象是一个叫做 other_script 的模块

00:02:00.260 --> 00:02:04.570
模块是具有 Python 定义和语句的文件

00:02:04.569 --> 00:02:06.954
当我们像这样导入 Python 文件时

00:02:06.954 --> 00:02:11.044
它会创建一个叫做 other_script 的对象 类型是模块

00:02:11.044 --> 00:02:14.974
我们来看一个导入模块的更有用示例

00:02:14.974 --> 00:02:20.155
这是一个包含实用函数的 Python 文件 我们将使用这些函数

00:02:20.155 --> 00:02:25.719
其中一个函数返回列表的均值 另一个使列表中的每个元素加 5

00:02:25.719 --> 00:02:28.199
我们可以将这些函数导入 demo.py

00:02:28.199 --> 00:02:32.560
输入 useful_functions. 然后是要使用的函数的名称

00:02:32.560 --> 00:02:35.500
可以想象 如果我们有很多在不同文件中经常使用的函数

00:02:35.500 --> 00:02:38.830
这样操作的话会很方便

00:02:38.830 --> 00:02:42.100
但是 每次我们想要使用某个文件中的函数时

00:02:42.099 --> 00:02:46.180
都需要输入整个文件名 这样很麻烦

00:02:46.180 --> 00:02:49.385
我们可以通过添加别名使这一切变得异常简单

00:02:49.384 --> 00:02:53.944
我将这个 useful_function 模块的别名设为 uf

00:02:53.944 --> 00:02:59.149
现在 当我调用该文件中的函数时 我可以直接输入 uf 而不用输入整个模块名

00:02:59.149 --> 00:03:01.849
当我们有要从其他 Python 脚本中导入的对象（例如函数）时

00:03:01.849 --> 00:03:04.810
这样会很方便

00:03:04.810 --> 00:03:07.060
但是如果该脚本除了包含函数定义之外

00:03:07.060 --> 00:03:12.219
还包含我们不希望导入的可执行语句呢

00:03:12.219 --> 00:03:16.585
例如 如果 useful_functions.py 在脚本底部

00:03:16.585 --> 00:03:21.000
具有测试函数并输出结果的代码呢

00:03:21.000 --> 00:03:26.455
如果我们运行 useful_functions.py 以测试这些函数时 这段代码比较实用

00:03:26.455 --> 00:03:31.550
但是如果我们只是尝试在另一个脚本中使用这些函数 则没必要运行这段代码

00:03:31.550 --> 00:03:35.615
我们可以使用语句“if __name__ == ‘__main__’”

00:03:35.615 --> 00:03:40.450
通过在这个 if name 块中包含这些可执行语句

00:03:40.449 --> 00:03:43.810
我们告诉 Python 仅当被执行的主程序

00:03:43.810 --> 00:03:48.490
是这个 useful_functions.py 时才执行这段代码

00:03:48.490 --> 00:03:52.995
如果我们运行这个文件 这个块中的代码将运行

00:03:52.995 --> 00:03:56.375
但是 如果我们运行另一个

00:03:56.375 --> 00:03:59.873
只是导入 useful_function.py 的脚本 这段代码不会运行

00:03:59.873 --> 00:04:04.629
通常建议在 if name 块中编写可执行语句

00:04:04.629 --> 00:04:07.870
或者将这些语句包含在函数 Main 中

00:04:07.870 --> 00:04:11.865
并在 if name 块中调用该函数

00:04:11.865 --> 00:04:15.475
你可能会疑问 __name__ 和 __main__ 是什么

00:04:15.474 --> 00:04:17.675
每当我们像这样运行脚本时

00:04:17.675 --> 00:04:21.370
Python 实际上会为任何模块设置一个特殊的内置变量

00:04:21.370 --> 00:04:26.305
叫做 __name__ 前后都有两个下划线

00:04:26.305 --> 00:04:30.009
在此处 因为我们运行的是 Python demo.py

00:04:30.009 --> 00:04:34.000
Python 发现它是主程序

00:04:34.000 --> 00:04:38.824
并将该模块的 __name__ 变量设为字符串 __main__

00:04:38.824 --> 00:04:42.314
对于该脚本导入的任何模块

00:04:42.314 --> 00:04:46.110
这个内置 __name__ 变量会设为该模块的名称

