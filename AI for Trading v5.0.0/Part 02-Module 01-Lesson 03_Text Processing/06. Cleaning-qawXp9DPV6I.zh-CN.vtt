WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.044
文本数据 特别是来自网络来源的文本数据

00:00:03.044 --> 00:00:05.250
几乎不可能是整洁的

00:00:05.250 --> 00:00:08.509
我们以优达学城的课程目录作为示例

00:00:08.509 --> 00:00:13.125
假如你想提取每个课程或纳米学位的标题和描述

00:00:13.125 --> 00:00:14.835
听起来很简单 对吧

00:00:14.835 --> 00:00:17.375
我们用 Python 试一下

00:00:17.375 --> 00:00:21.865
可以下载并启动用于处理文本的 notebook

00:00:21.864 --> 00:00:29.719
像任何其它在线资源一样 可以使用 request 库来获取网页

00:00:29.719 --> 00:00:33.420
看起来得到了全部 HTML 源代码

00:00:33.420 --> 00:00:36.500
这正是浏览器显示网页所需的东西

00:00:36.500 --> 00:00:39.719
但是大多数对我们来说没用

00:00:39.719 --> 00:00:44.929
我们需要提取网站上可见的所有纯文本

00:00:44.929 --> 00:00:47.884
使用正则表达式怎么样？

00:00:47.884 --> 00:00:49.534
我们定义一个模式

00:00:49.534 --> 00:00:54.464
匹配所有 HTML 标签 并用空字符串替换它们 将其清除

00:00:54.465 --> 00:00:56.915
这个方法有点用

00:00:56.914 --> 00:01:01.269
可以看到 网页标题已经成功提取

00:01:01.270 --> 00:01:06.859
但是仍然有很多不需要的 JavaScript 和其它项目

00:01:06.859 --> 00:01:11.269
实际上 这种正则表达式在某种程度上没有区配一些标签

00:01:11.269 --> 00:01:13.754
它们可能嵌套在其它标签内

00:01:13.754 --> 00:01:17.069
我们可能需要找出分布在行之间的标签

00:01:17.069 --> 00:01:21.019
总之 这好像不是最好的方法

00:01:21.019 --> 00:01:24.250
我们真正需要的是对 HTML 进行解析

00:01:24.250 --> 00:01:25.715
就像网页浏览器

00:01:25.715 --> 00:01:28.079
然后提取相关元素

00:01:28.079 --> 00:01:30.590
我们现在介绍 Beautiful Soup

00:01:30.590 --> 00:01:33.900
这是一个很有效的 Python 库 专用于这个用途

00:01:33.900 --> 00:01:37.550
可以传入原始网页文本（在该示例中 包含 HTML）

00:01:37.549 --> 00:01:41.269
以创建 soup 对象

00:01:41.269 --> 00:01:43.564
用 简单的get-text 方法

00:01:43.564 --> 00:01:49.099
提取HTML标签后的纯文本

00:01:49.099 --> 00:01:50.974
这种方法也针对嵌套标签

00:01:50.974 --> 00:01:53.044
跨行的标签

00:01:53.045 --> 00:01:58.185
以及增加 HTML 解析难度的多种其它极端情况

00:01:58.185 --> 00:02:02.120
像浏览器一样 它还会忽略HTML 中的一些小错误

00:02:02.120 --> 00:02:05.765
使其更稳健 我们看一下

00:02:05.765 --> 00:02:10.960
现在好多了

00:02:10.960 --> 00:02:13.090
看不到任何 HTML 标签

00:02:13.090 --> 00:02:17.990
但是仍然有很多 JavaScript 和空格

00:02:17.990 --> 00:02:23.620
我们还能怎么做？ 我们看一下 HTML 源代码的结构

00:02:23.620 --> 00:02:28.325
最简单的方法是 随便右击一个元素

00:02:28.324 --> 00:02:30.129
例如这个课程标题

00:02:30.129 --> 00:02:34.159
然后选择“检查元素” 或者 “查看网页来源”

00:02:34.159 --> 00:02:37.840
现在看一下标题在什么位置

00:02:37.840 --> 00:02:43.125
要在 HTML 文件中找到这个标题 最好的方法是什么？

00:02:43.125 --> 00:02:47.745
这里有一个父块 包含一个“课程摘要卡”类

00:02:47.745 --> 00:02:50.950
好像有用 我们用一下

00:02:50.949 --> 00:02:54.354
Beautiful Soup 实际非常强大

00:02:54.354 --> 00:02:59.034
它能让你通过多种不同方法对 DOM 树进行通览

00:02:59.034 --> 00:03:04.889
我们现在用该库找到含有“课程摘要卡”类的所有块

00:03:04.889 --> 00:03:09.534
返回的结果是文件中所有这种块的列表

00:03:09.534 --> 00:03:13.375
我们把它存储在变量中 看其中一个块

00:03:13.375 --> 00:03:16.460
好了 滚动页面

00:03:16.460 --> 00:03:23.710
我发现标题存储在这个 a 标签中 而 a 标签包含在这个 H3 标签中

00:03:23.710 --> 00:03:26.409
如何提取这个标题？

00:03:26.409 --> 00:03:29.539
一种方法是使用 CSS 选择器

00:03:29.539 --> 00:03:36.209
现在可以像之前一样 找到纯文本内容

00:03:36.210 --> 00:03:38.135
很好 还有最后一步

00:03:38.134 --> 00:03:43.379
删除两端的多余空格 好了

00:03:43.379 --> 00:03:47.189
现在再看 HTML 看看如何

00:03:47.189 --> 00:03:51.300
提取描述文本 就是这个

00:03:51.300 --> 00:03:56.805
这个块包含名为 “data-course-short-summary” 的属性

00:03:56.805 --> 00:04:00.939
但是不含值和任何其它属性

00:04:00.939 --> 00:04:04.699
这是一种通过 CSS 选择这种标签的方法

00:04:04.699 --> 00:04:07.629
指定标签名 这里是 div

00:04:07.629 --> 00:04:12.944
后面用方括号写上属性名称 很好

00:04:12.944 --> 00:04:15.944
现在提取文本 并进行清洗

00:04:15.944 --> 00:04:20.849
好了 现在可以对所有课程摘要重复这个过程

00:04:20.850 --> 00:04:24.500
为此 可以使用简单的 for 循环

00:04:24.500 --> 00:04:26.944
我认为非常准确

00:04:26.944 --> 00:04:30.444
存储这个数据 便于以后使用

00:04:30.444 --> 00:04:35.079
这里 我们只是简单地将数据保存在名为“课程”的列表中

00:04:35.079 --> 00:04:38.784
刚才的过程叫做网页抓取

00:04:38.785 --> 00:04:41.050
虽然听起来有点暴力

00:04:41.050 --> 00:04:42.550
相信我 并不是

00:04:42.550 --> 00:04:45.340
实际上网页抓取非常常见

00:04:45.339 --> 00:04:48.069
Google News 就是一个很好的例子

00:04:48.069 --> 00:04:54.634
它从新闻文章中提取标题和开头的一两个句子 将其显示出来

00:04:54.634 --> 00:04:57.279
Google 可能是利用多种规则和

00:04:57.279 --> 00:05:00.069
机器学习 识别 HTML 的哪个部分

00:05:00.069 --> 00:05:02.349
包含文章文本的标题和开头

00:05:02.350 --> 00:05:06.245
将其作为预览

00:05:06.245 --> 00:05:08.035
大多数情况下会成功

00:05:08.035 --> 00:05:10.450
但有时会失败

00:05:10.449 --> 00:05:13.870
这篇有关量子纠缠的文章

00:05:13.870 --> 00:05:17.920
其预览好像与标题毫不相干

00:05:17.920 --> 00:05:22.090
更像是这个图片的说明

00:05:22.089 --> 00:05:26.769
可能因为图片说明是网页文本的第一部分

00:05:26.769 --> 00:05:32.979
Google 的算法将其作为文章主体的一部分进行提取

00:05:32.980 --> 00:05:36.220
这说明 看似常规的任务和

00:05:36.220 --> 00:05:40.145
文本处理问题 仍然不能被完美解决

00:05:40.144 --> 00:05:43.969
我们再看一下刚才的成果

00:05:43.970 --> 00:05:46.875
我们得到了一个网页

00:05:46.875 --> 00:05:48.910
优达学城的课程目录

00:05:48.910 --> 00:05:53.040
然后尝试了几种方法 清除 HTML 标签

00:05:53.040 --> 00:05:57.672
最后用 BeautifulSoup 对整个 HTML 源代码进行解析

00:05:57.672 --> 00:05:59.515
找到所有课程摘要

00:05:59.514 --> 00:06:03.189
提取每个课程的标题和描述

00:06:03.189 --> 00:06:05.605
然后全部保存到一个列表

00:06:05.605 --> 00:06:08.302
根据后续计划

00:06:08.302 --> 00:06:11.199
可以将这些块作为一个文档的一部分

00:06:11.199 --> 00:06:15.819
或者将每个块作为单独的文档

00:06:15.819 --> 00:06:17.067
如果你想将相关课程归类

00:06:17.067 --> 00:06:20.529
第二种方式更好

00:06:20.529 --> 00:06:24.000
剩下的问题便是文档聚类

