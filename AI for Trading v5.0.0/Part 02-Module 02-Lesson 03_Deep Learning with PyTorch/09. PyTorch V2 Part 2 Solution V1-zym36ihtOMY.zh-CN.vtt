WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.685
下面说说

00:00:02.685 --> 00:00:04.695
我如何使用多层神经网络

00:00:04.695 --> 00:00:08.505
分类 MNIST 数据集中的手写数字

00:00:08.505 --> 00:00:11.850
像之前一样定义激活函数

00:00:11.850 --> 00:00:15.465
这是 S 型函数 在这里扁平化图像

00:00:15.465 --> 00:00:19.860
还记得如何变形张量吧

00:00:19.860 --> 00:00:21.285
使用 .view

00:00:21.285 --> 00:00:23.580
传入批次大小

00:00:23.580 --> 00:00:25.185
images.shape()

00:00:25.185 --> 00:00:27.720
第一个图像是 0

00:00:27.720 --> 00:00:32.925
获得图像张量里的批次数量

00:00:32.925 --> 00:00:35.460
我希望批次数量可以不变

00:00:35.460 --> 00:00:38.385
但是我要扁平化其他维度

00:00:38.385 --> 00:00:41.150
所以 可以在这里输入 -1

00:00:41.150 --> 00:00:44.600
其实我也可以在这里输入 784

00:00:44.600 --> 00:00:48.410
但是更简便的方式是输入 -1

00:00:48.410 --> 00:00:54.980
在这里传入批次大小 64

00:00:54.980 --> 00:00:58.100
当你在这里输入 -1 时

00:00:58.100 --> 00:01:02.270
它将设定相应的大小 保持元素总数不变

00:01:02.270 --> 00:01:07.220
它将自己判断第二个维度必须是 784

00:01:07.220 --> 00:01:10.220
这样的话 变形之后

00:01:10.220 --> 00:01:13.675
元素的数量和变形之前的一样

00:01:13.675 --> 00:01:17.135
这样可以快速扁平化张量

00:01:17.135 --> 00:01:21.245
我们不需要知道第二个维度的大小是多少

00:01:21.245 --> 00:01:25.025
在这里设置权重和偏差参数

00:01:25.025 --> 00:01:33.020
我们希望有 784 个输入单元 256 个隐藏单元

00:01:33.020 --> 00:01:37.070
第一个权重矩阵将是 784 x 256

00:01:37.070 --> 00:01:41.360
每个隐藏单元都需要一个偏差项

00:01:41.360 --> 00:01:45.120
因此 b1 中有 256 个偏差项

00:01:45.120 --> 00:01:48.830
第二个权重连接的是隐藏层和输出层

00:01:48.830 --> 00:01:53.570
我们希望有 256 个输入和 10 个输出

00:01:53.570 --> 00:01:55.685
偏差是 10 个元素

00:01:55.685 --> 00:02:02.630
和之前一样 我们可以进行矩阵乘法运算

00:02:02.630 --> 00:02:04.190
将输入与第一组权重参数相乘

00:02:04.190 --> 00:02:07.640
加上偏差项

00:02:07.640 --> 00:02:10.940
然后传入激活函数 得出隐藏层的输出

00:02:10.940 --> 00:02:15.395
然后将该输出当做输出层的输入

00:02:15.395 --> 00:02:19.970
再次与第二组权重相乘并加上第二组偏差项

00:02:19.970 --> 00:02:23.135
获得网络的输出好了

00:02:23.135 --> 00:02:26.210
来看下网络的输出

00:02:26.210 --> 00:02:29.450
有 64 行

00:02:29.450 --> 00:02:32.630
先输出形状 确保操作正确

00:02:32.630 --> 00:02:40.165
有 64 行 表示 64 个输入样本 然后是 10 个值

00:02:40.165 --> 00:02:42.530
这个值表示

00:02:42.530 --> 00:02:46.415
图像属于这个类别/数字

00:02:46.415 --> 00:02:50.530
我们查看下输出张量

00:02:50.530 --> 00:02:53.640
有大量的值

00:02:53.640 --> 00:02:57.145
6 -11 等等

00:02:57.145 --> 00:03:00.470
但是我们希望给定某个图像后

00:03:00.470 --> 00:03:04.160
网络能告诉我们图像属于各个类别的概率是多少

00:03:04.160 --> 00:03:09.500
如果我们向网络中传入图像

00:03:09.500 --> 00:03:12.050
输出应该是一个概率分布

00:03:12.050 --> 00:03:16.565
告诉我们图像最有可能属于哪个类别/数字

00:03:16.565 --> 00:03:19.255
如果图像是 6

00:03:19.255 --> 00:03:21.830
那么输出应该是一个概率分布

00:03:21.830 --> 00:03:24.995
最高的概率是第六个类别

00:03:24.995 --> 00:03:27.115
告诉我们它是数字 6

00:03:27.115 --> 00:03:29.375
我们希望网络的判断是

00:03:29.375 --> 00:03:31.520
基于每个类别的概率

00:03:31.520 --> 00:03:33.725
给定传入的图像后

00:03:33.725 --> 00:03:37.815
该图像属于不同类别的概率是多少

00:03:37.815 --> 00:03:39.605
可以看出

00:03:39.605 --> 00:03:41.450
每个类别的概率大致相同

00:03:41.450 --> 00:03:43.985
因此是一个均匀分布

00:03:43.985 --> 00:03:46.310
表明网络没有经过训练

00:03:46.310 --> 00:03:49.165
所以是均匀概率分布

00:03:49.165 --> 00:03:51.050
这是因为网络尚未见过任何数据

00:03:51.050 --> 00:03:53.495
还没有学习关于这些图像的任何规律

00:03:53.495 --> 00:03:57.005
即使你传入一个图像  无论传入的图像是什么

00:03:57.005 --> 00:04:00.950
它都不知道图像是什么 

00:04:00.950 --> 00:04:03.370
只是给出每个类别概率相等的分布 

00:04:03.370 --> 00:04:07.355
我们希望网络的输出

00:04:07.355 --> 00:04:10.670
是一个概率分布

00:04:10.670 --> 00:04:14.960
告诉我们图像属于任何一个类别的概率

00:04:14.960 --> 00:04:17.945
所以 我们将使用 softmax 函数

00:04:17.945 --> 00:04:20.540
这是指数函数

00:04:20.540 --> 00:04:22.670
传入 10 个值

00:04:22.670 --> 00:04:24.455
对于每个值

00:04:24.455 --> 00:04:26.765
我们都使该值的指数

00:04:26.765 --> 00:04:29.555
除以所有值的指数之和

00:04:29.555 --> 00:04:33.140
该函数的作用是

00:04:33.140 --> 00:04:36.680
将输入值 x 压缩到 0 和 1 之间

00:04:36.680 --> 00:04:39.470
然后标准化所有值

00:04:39.470 --> 00:04:42.870
使概率之和为 1

00:04:42.870 --> 00:04:44.940
即所有值相加为 1

00:04:44.940 --> 00:04:47.525
这样就获得了我们想要的概率和为1的概率分布

00:04:47.525 --> 00:04:50.225
下面你的任务是

00:04:50.225 --> 00:04:54.310
实现这个 softmax 函数并完成这一计算过程

00:04:54.310 --> 00:04:57.800
即获取这个简单神经网络的输出

00:04:57.800 --> 00:05:02.705
形状为 64 x 10

00:05:02.705 --> 00:05:06.695
将其传入函数 softmax 中

00:05:06.695 --> 00:05:11.660
确保对于传入的每个样本 

00:05:11.660 --> 00:05:13.130
它都会计算样本的概率分布加油！

