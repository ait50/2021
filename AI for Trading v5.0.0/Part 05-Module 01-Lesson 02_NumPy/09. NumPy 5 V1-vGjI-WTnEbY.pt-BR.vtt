WEBVTT
Kind: captions
Language: pt-BR

00:00:00.034 --> 00:00:04.435
Até agora vimos como criar fatias
e selecionar elementos

00:00:04.468 --> 00:00:07.371
de um array do NumPy,
usando índices.

00:00:07.404 --> 00:00:10.250
É útil quando sabemos
os índices exatos

00:00:10.283 --> 00:00:12.387
dos elementos que queremos.

00:00:12.420 --> 00:00:16.074
Mas existem muitas situações
nas quais não sabemos os índices

00:00:16.107 --> 00:00:18.562
dos elementos que queremos.

00:00:18.595 --> 00:00:21.898
Vamos supor que eu tenha
um array de 10 mil por 10 mil,

00:00:21.931 --> 00:00:26.018
de inteiros aleatórios,
que vão de 1 a 15 mil,

00:00:26.051 --> 00:00:29.906
e só queremos selecionar inteiros
menores que 20.

00:00:29.939 --> 00:00:33.210
O índice booleano
pode nos ajudar nesses casos,

00:00:33.243 --> 00:00:36.882
selecionando elementos
usando argumentos lógicos

00:00:36.915 --> 00:00:39.098
em vez de índices
explícitos.

00:00:39.131 --> 00:00:40.946
Vamos ver exemplos.

00:00:41.130 --> 00:00:46.434
Considere este array 5 por 5,
que vai de zero a 24.

00:00:46.666 --> 00:00:49.706
Podemos usar o índice booleano
para selecionar elementos

00:00:49.739 --> 00:00:51.205
maiores que 10.

00:00:51.549 --> 00:00:52.917
Assim.

00:00:52.950 --> 00:00:56.740
Em vez de índices,
usamos uma expressão booleana.

00:00:56.773 --> 00:01:00.629
Vamos pegar os elementos
menores ou iguais a 7.

00:01:00.662 --> 00:01:04.916
Agora os maiores que 7
e menores que 17.

00:01:04.949 --> 00:01:08.253
Podemos usar o índice booleano
para designar os elementos

00:01:08.286 --> 00:01:12.717
entre 10 e 17
ao valor de -1.

00:01:12.965 --> 00:01:15.292
Além do índice booleano,

00:01:15.325 --> 00:01:18.981
o NumPy também permite
operações de conjunto.

00:01:19.014 --> 00:01:22.421
Isso é útil na comparação
de dois arrays do NumPy.

00:01:22.454 --> 00:01:25.173
Por exemplo, para encontrar
elementos em comum.

00:01:25.206 --> 00:01:27.813
Considere
estes dois arrays nível 1.

00:01:28.461 --> 00:01:31.549
Podemos criar arrays
para a interseção,

00:01:31.582 --> 00:01:34.093
a diferença e a união.

00:01:34.653 --> 00:01:37.462
Também podemos ordenar
os arrays do NumPy.

00:01:37.495 --> 00:01:40.158
Vamos usar a função sort do NumPy
para ordenar

00:01:40.191 --> 00:01:43.253
arrays de nível 1 e 2
de maneiras diferentes.

00:01:43.286 --> 00:01:45.725
Como as outras funções
que vimos,

00:01:45.758 --> 00:01:48.853
a função sort também pode
ser usada como método.

00:01:48.886 --> 00:01:50.709
Mas existe
uma grande diferença

00:01:50.742 --> 00:01:53.925
no armazenamento
dos dados na memória.

00:01:53.958 --> 00:01:56.511
Quando sort é usado
como função,

00:01:56.544 --> 00:01:59.470
ele ordena os arrays
por fora,

00:01:59.503 --> 00:02:02.470
ou seja,
o array original não é alterado.

00:02:02.503 --> 00:02:05.118
Mas ao usar sort
como método,

00:02:05.151 --> 00:02:07.285
o array é ordenado
por dentro,

00:02:07.318 --> 00:02:10.326
ou seja,
o array original é alterado.

00:02:10.359 --> 00:02:13.126
Vamos criar um array nível 1
não ordenado.

00:02:13.159 --> 00:02:16.478
Podemos ordenar X
usando sort como função.

00:02:16.701 --> 00:02:21.286
X vai ser ordenado por fora,
deixando o array como está.

00:02:21.319 --> 00:02:25.657
Como pode ver, a NumPy.sort
ordenou o array X,

00:02:26.161 --> 00:02:29.105
mas X não mudou.

00:02:29.138 --> 00:02:32.761
O array é ordenado
mantendo os valores repetidos.

00:02:32.794 --> 00:02:35.802
Se quiser ordenar
só elementos únicos no X,

00:02:35.835 --> 00:02:38.625
você pode usar
a função unique.

00:02:38.978 --> 00:02:41.922
Vamos ver como ordenar
os arrays por dentro

00:02:41.955 --> 00:02:44.201
usando sort como método.

00:02:44.234 --> 00:02:45.705
Aqui está X.

00:02:45.738 --> 00:02:47.634
Se ordenarmos X assim,

00:02:47.667 --> 00:02:51.409
vamos ver que afeta o X original,
que é ordenado.

00:02:51.442 --> 00:02:53.482
Ao ordenar arrays nível 2,

00:02:53.515 --> 00:02:56.586
precisamos dizer para a função
se vai ser por fileira

00:02:56.619 --> 00:02:58.273
ou por coluna.

00:02:58.306 --> 00:03:01.225
Isso é feito
com a palavra-chave "axis".

00:03:01.513 --> 00:03:04.322
Temos um array nível 2
não ordenado.

00:03:04.355 --> 00:03:07.386
Podemos ordenar X
por fileiras.

00:03:07.586 --> 00:03:09.362
Aqui está.

00:03:09.395 --> 00:03:12.546
Ou podemos ordenar X
por colunas.

00:03:12.579 --> 00:03:13.700
Aqui está.

