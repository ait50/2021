WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.350
到目前为止 我们已经知道怎么用索引

00:00:03.350 --> 00:00:07.054
对 NumPy 数组进行切片并选择其元素了

00:00:07.054 --> 00:00:12.059
如果我们知道目标元素的具体索引 这些方法的确很实用

00:00:12.060 --> 00:00:14.370
但很多时候

00:00:14.369 --> 00:00:17.149
我们并不清楚目标元素的索引

00:00:17.149 --> 00:00:23.099
比如 假设我们有一个 10000 x 10000 的随机整数数组

00:00:23.100 --> 00:00:29.640
其范围在 1 到 15000 之间 但我们只想选出其中小于 20 的整数

00:00:29.640 --> 00:00:34.200
这个时候布尔索引就派上了用场

00:00:34.200 --> 00:00:38.870
借助逻辑参数而非具体索引 布尔索引能帮我们选出想要的元素

00:00:38.869 --> 00:00:40.744
我们来看些例子

00:00:40.744 --> 00:00:46.239
这是个 5 x 5 的数组 范围在 0 到 24 之间

00:00:46.240 --> 00:00:51.050
我们可以用布尔索引选出大于 10 的元素

00:00:51.049 --> 00:00:54.029
像这样 这个时候我们不用索引

00:00:54.030 --> 00:00:56.384
而是用布尔表达式

00:00:56.384 --> 00:00:59.899
我们还可以提取出小于或等于 7 的元素

00:00:59.899 --> 00:01:04.500
或者大于 7 且小于 17 的元素

00:01:04.500 --> 00:01:08.269
我们还可以用布尔索引

00:01:08.269 --> 00:01:12.524
给 10 到 17 之间的元素赋值 使其值变为 -1

00:01:12.525 --> 00:01:15.075
除了布尔索引

00:01:15.075 --> 00:01:18.575
NumPy 还能进行集合运算

00:01:18.575 --> 00:01:22.130
这很方便我们比较两个 NumPy 数组

00:01:22.129 --> 00:01:24.814
比如找出数组的共同元素

00:01:24.814 --> 00:01:28.114
来看这两个秩为 1 的数组

00:01:28.114 --> 00:01:33.109
我们可以进行交、差、并集合运算 从而创建新数组

00:01:33.109 --> 00:01:37.090
像这样 我们还可以给 NumPy 数组排序

00:01:37.090 --> 00:01:42.975
我们来用 NumPy 函数 sort 分别给秩为 1 和秩为 2 的数组排序

00:01:42.974 --> 00:01:45.405
和我们之前看到的其它函数一样

00:01:45.405 --> 00:01:48.555
函数 sort 也可以当方法用

00:01:48.555 --> 00:01:53.550
但其数据在内存中的存储方式会有所不同

00:01:53.549 --> 00:01:56.099
如果把 sort 当函数用

00:01:56.099 --> 00:01:59.059
函数会在别的地方对 NumPy 数组进行排序

00:01:59.060 --> 00:02:02.189
也就是说 操作不会改变原数组

00:02:02.189 --> 00:02:04.890
如果将 sort 当方法用

00:02:04.890 --> 00:02:06.989
那数组会在原地进行排序

00:02:06.989 --> 00:02:10.049
也即原数组也会有变化

00:02:10.050 --> 00:02:12.870
我们先创建一个秩为 1 的无序数组

00:02:12.870 --> 00:02:16.240
把 sort 当作函数 给 x 排序

00:02:16.240 --> 00:02:20.980
函数会在其它地方给 x 排序 不改动原数组

00:02:20.979 --> 00:02:25.750
正如你所见 np.sort 的确对 x 数组进行了排序

00:02:25.750 --> 00:02:28.759
但 x 本身没有变化

00:02:28.759 --> 00:02:32.465
注意 排序操作不会删除重复元素

00:02:32.465 --> 00:02:35.590
如果不想排序后 x 还有重复元素

00:02:35.590 --> 00:02:38.620
你可以结合使用 sort 和函数 unique 就像这样

00:02:38.620 --> 00:02:45.254
现在 我们来看怎么把 sort 当方法用 在原地给数组排序 还是这个数组 x

00:02:45.254 --> 00:02:47.144
像这样给数组排序

00:02:47.145 --> 00:02:50.975
我们会发现 原数组 x 也排好序了

00:02:50.974 --> 00:02:53.074
在给秩为 2 的数组排序时

00:02:53.074 --> 00:02:57.754
我们得告诉函数 sort 排序应按行还是按列进行

00:02:57.754 --> 00:03:01.064
因此我们要用关键字 axis

00:03:01.064 --> 00:03:03.939
这是个秩为 2 的无序数组

00:03:03.939 --> 00:03:07.050
我们可以像这样按行对 x 进行排序 如图

00:03:07.050 --> 00:03:14.130
也可以像这样按列对 x 进行排序 如图

