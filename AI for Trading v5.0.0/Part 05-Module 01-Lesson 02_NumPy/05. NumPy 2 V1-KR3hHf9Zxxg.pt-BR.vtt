WEBVTT
Kind: captions
Language: pt-BR

00:00:00.067 --> 00:00:04.100
Nó último vídeo,
aprendemos a criar arrays NumPy

00:00:04.133 --> 00:00:08.867
ao converter objetos similares
a arrays, como as listas Python,

00:00:08.900 --> 00:00:11.067
usando a função array
do NumPy.

00:00:11.100 --> 00:00:14.600
Mas um recurso do NumPy
que ajuda a economizar tempo

00:00:14.633 --> 00:00:18.567
é a habilidade de gerar tipos
específicos de arrays NumPy

00:00:18.600 --> 00:00:19.767
do nada,

00:00:19.800 --> 00:00:21.533
usando apenas
uma linha de código.

00:00:21.567 --> 00:00:25.767
Aqui, veremos algumas
das funções built-in mais úteis

00:00:25.800 --> 00:00:27.733
para gerar arrays NumPy.

00:00:28.133 --> 00:00:31.667
Vamos começar criando
um array NumPy de zeros

00:00:31.700 --> 00:00:33.767
com um formato especificado
por nós.

00:00:33.900 --> 00:00:37.700
Podemos fazer isso usando
a função zeros do NumPy.

00:00:37.733 --> 00:00:41.767
Essa função usa como argumento
o formato do array

00:00:41.800 --> 00:00:43.033
que você quer criar.

00:00:43.067 --> 00:00:46.000
Ao passar pela tupla "3, 4"

00:00:46.033 --> 00:00:49.567
temos um array de 3 por 4
de zeros.

00:00:49.600 --> 00:00:54.600
Como padrão, isso cria um array
com tipo de dados float64.

00:00:54.633 --> 00:00:57.267
Se você quiser usar
um tipo de dados diferente,

00:00:57.300 --> 00:01:00.700
é possível mudar isso
com a palavra-chave "dtype".

00:01:00.733 --> 00:01:04.400
Da mesma forma, podemos criar
um NumPy array de números 1

00:01:04.433 --> 00:01:05.967
usando essa função,

00:01:06.000 --> 00:01:09.100
que também tem o formato
de um argumento.

00:01:09.133 --> 00:01:11.633
Além dos números 1 e 0,

00:01:11.667 --> 00:01:15.467
é possível criar um array
com qualquer valor constante

00:01:15.500 --> 00:01:18.000
usando a função full.

00:01:18.033 --> 00:01:19.933
Para isso,
é preciso dois argumentos:

00:01:19.967 --> 00:01:24.167
o formato do array e a constante
com a qual vai preenchê-lo.

00:01:24.200 --> 00:01:26.267
A função full
tem como padrão

00:01:26.300 --> 00:01:28.433
criar um array
com o tipo de dados

00:01:28.467 --> 00:01:31.567
do valor que você colocou
como constante.

00:01:31.600 --> 00:01:35.833
Aqui, como colocamos o
número inteiro 5 como constante,

00:01:35.867 --> 00:01:40.300
isso gerou um array
com o dtype int64.

00:01:40.333 --> 00:01:44.333
Use a palavra-chave "dtype"
para especificar variações.

00:01:44.367 --> 00:01:47.200
Um array fundamental
de álgebra linear

00:01:47.233 --> 00:01:49.533
é a matriz identidade.

00:01:49.567 --> 00:01:54.700
Matriz é outro termo usado para
descrever um array bidimensional

00:01:54.800 --> 00:01:56.767
com linhas e colunas.

00:01:56.800 --> 00:02:00.733
E uma matriz identidade é apenas
uma matriz em formato quadrado

00:02:00.767 --> 00:02:03.500
que tem números 1 ao longo
de sua diagonal principal

00:02:03.533 --> 00:02:05.633
e zeros no resto.

00:02:06.100 --> 00:02:09.767
A função eye do NumPy
pode ser usada para criar isso.

00:02:09.800 --> 00:02:13.267
Como todas as matrizes
identidade são quadradas,

00:02:13.300 --> 00:02:16.733
isso só precisa de um
número inteiro como argumento.

00:02:16.767 --> 00:02:17.967
Se usarmos 5,

00:02:18.000 --> 00:02:20.900
teremos uma matriz identidade
de 5 por 5.

00:02:20.933 --> 00:02:22.300
E sua diagonal principal,

00:02:22.333 --> 00:02:25.633
que vai do canto superior
esquerdo ao inferior direito,

00:02:25.667 --> 00:02:27.433
está cheia de números 1.

00:02:27.467 --> 00:02:30.200
Também podemos usar
a função diag de NumPy

00:02:30.233 --> 00:02:32.400
para criar
uma matriz diagonal.

00:02:32.900 --> 00:02:36.833
Essa função aceita a entrada
de uma sequência de valores

00:02:36.867 --> 00:02:38.900
para usar
como diagonal principal

00:02:38.933 --> 00:02:40.767
de uma matriz quadrada

00:02:40.800 --> 00:02:42.767
e preenche o restante
com zeros.

00:02:43.200 --> 00:02:47.067
NumPy também tem funções úteis
para gerar arrays

00:02:47.100 --> 00:02:49.867
com intervalos numéricos
específicos.

00:02:49.900 --> 00:02:52.367
Uma função útil é a arange,

00:02:52.400 --> 00:02:56.567
que cria um array unidimensional
de valores igualmente espaçados

00:02:56.600 --> 00:02:58.600
dentro
de um determinado intervalo.

00:02:58.633 --> 00:03:00.400
Para isso,
é preciso três argumentos:

00:03:00.433 --> 00:03:03.267
start, stop e step.

00:03:03.300 --> 00:03:04.967
Mas ainda podemos usar isso

00:03:05.000 --> 00:03:09.433
se quisermos especificar
um, dois ou três argumentos.

00:03:09.467 --> 00:03:11.333
Vamos ver cada caso.

00:03:11.367 --> 00:03:13.900
Quando apenas um número inteiro
é especificado,

00:03:13.933 --> 00:03:17.267
arange usa isso
como um argumento stop,

00:03:17.300 --> 00:03:19.333
e gera um array
de números inteiros

00:03:19.367 --> 00:03:22.600
de 0 até aquele inteiro
menos 1.

00:03:22.633 --> 00:03:25.167
O argumento stop
é exclusivo,

00:03:25.200 --> 00:03:27.433
por isso temos
que subtrair 1.

00:03:27.467 --> 00:03:33.067
Por exemplo, arange 10 nos
dá um array de 0 a 10 menos 1,

00:03:33.100 --> 00:03:34.467
que é igual a 9.

00:03:34.500 --> 00:03:37.000
Quando usado
com dois argumentos,

00:03:37.033 --> 00:03:40.300
arange usa o primeiro
como o argumento start

00:03:40.333 --> 00:03:43.267
e o segundo
como argumento stop.

00:03:43.300 --> 00:03:47.033
O start é inclusivo,
e o stop é exclusivo.

00:03:47.700 --> 00:03:53.300
Arange "4, 10"
nos dá um array de 4 a 9.

00:03:53.333 --> 00:03:55.400
Quando usamos 3 argumentos,

00:03:55.433 --> 00:03:59.133
arange gera um array
do primeiro número inteiro

00:03:59.167 --> 00:04:01.167
até o segundo número
menos 1,

00:04:01.200 --> 00:04:03.433
separado igualmente
pelo terceiro.

00:04:03.467 --> 00:04:06.133
Esse terceiro argumento,
o step,

00:04:06.167 --> 00:04:10.167
é a distância entre quaisquer
dois valores desse array.

00:04:10.200 --> 00:04:15.200
Quando especificamos somente
um ou dois argumentos no arange,

00:04:15.233 --> 00:04:17.733
o step coloca 1 como padrão.

00:04:17.767 --> 00:04:19.900
Mesmo que a função arange
do NumPy

00:04:19.933 --> 00:04:23.767
permita steps de
números não inteiros, como 0.3,

00:04:23.800 --> 00:04:26.267
o resultado normalmente
é inconsistente,

00:04:26.300 --> 00:04:28.900
devido à precisão finita
do ponto flutuante.

00:04:28.933 --> 00:04:32.333
Por essa razão, quando queremos
steps de números não inteiros,

00:04:32.367 --> 00:04:37.267
é melhor usar uma função
NumPy diferente, a linspace.

00:04:37.300 --> 00:04:42.667
Ela precisa de três argumentos:
start, stop e N.

00:04:43.000 --> 00:04:46.600
Isso retorna números N
igualmente espaçados

00:04:46.633 --> 00:04:48.600
de start a stop.

00:04:48.633 --> 00:04:51.800
Sendo que start e stop
são ambos inclusivos.

00:04:51.833 --> 00:04:53.333
Ao contrário da arange,

00:04:53.367 --> 00:04:56.133
a função linspace exige
pelo menos dois argumentos

00:04:56.167 --> 00:04:57.867
para start e step.

00:04:57.900 --> 00:05:01.967
Se N não for especificado,
será considerado 50.

00:05:02.000 --> 00:05:03.767
Vamos ver alguns exemplos.

00:05:03.800 --> 00:05:05.533
Aqui temos um array rank 1

00:05:05.567 --> 00:05:09.900
com 10 números igualmente
espaçados, de 0 a 25.

00:05:09.933 --> 00:05:15.767
Mais uma vez, note que os pontos
start e stop são inclusivos.

00:05:15.800 --> 00:05:18.900
Mas você pode permitir
que o endpoint do intervalo

00:05:18.933 --> 00:05:22.733
seja excluído,
assim como na função arange,

00:05:22.767 --> 00:05:27.167
se você configurar o endpoint
da palavra-chave para falso.

00:05:27.333 --> 00:05:32.133
Como você pode ver, como
excluímos o endpoint 25,

00:05:32.167 --> 00:05:34.867
o espaço entre os valores
teve que mudar

00:05:34.900 --> 00:05:37.367
para caber 10 números
igualmente espaçados

00:05:37.400 --> 00:05:39.200
no dado intervalo.

00:05:39.233 --> 00:05:43.267
Até agora só usamos
as funções arange e linspace

00:05:43.300 --> 00:05:45.900
para criar arrays de rank 1.

00:05:45.933 --> 00:05:49.967
Mas podemos usar essas funções
para criar arrays de rank 2

00:05:50.000 --> 00:05:51.200
de qualquer formato

00:05:51.233 --> 00:05:55.000
ao combiná-las
com a função reshape do NumPy.

00:05:55.033 --> 00:05:57.600
Essa função converte
qualquer array NumPy

00:05:57.633 --> 00:05:59.733
em um formato especificado.

00:05:59.767 --> 00:06:03.200
É importante saber que
o novo formato especificado aqui

00:06:03.233 --> 00:06:07.400
deve ser compatível com o número
de elementos do array.

00:06:07.433 --> 00:06:10.767
Por exemplo, você pode converter
um array de rank 1

00:06:10.800 --> 00:06:12.233
com 20 elementos

00:06:12.267 --> 00:06:15.400
em um array de 4 por 5
de rank 2,

00:06:15.433 --> 00:06:18.200
ou em um array de 10 por 2,

00:06:18.233 --> 00:06:23.333
já que ambos os arrays de rank 2
ainda têm 20 elementos.

00:06:23.400 --> 00:06:28.467
Mas você pode transformar isso
em um array de 5 por 5,

00:06:28.500 --> 00:06:32.333
já que esse array de rank 2
teria 25 elementos,

00:06:32.367 --> 00:06:34.500
que é um número maior
de elementos

00:06:34.533 --> 00:06:36.633
do que
no array NumPy original.

00:06:36.667 --> 00:06:39.033
Um ótimo recurso do NumPy

00:06:39.067 --> 00:06:42.667
é poder aplicar algumas funções
como métodos.

00:06:43.067 --> 00:06:46.300
Isso nos permite aplicar
funções diferentes em sequência

00:06:46.333 --> 00:06:48.100
em apenas
uma linha de código.

00:06:48.133 --> 00:06:51.967
Métodos de array NumPy
são similares aos atributos,

00:06:52.000 --> 00:06:55.300
já que ambos são aplicados
ao usarmos notação de ponto.

00:06:55.333 --> 00:06:59.633
Vamos ver como conseguimos
o mesmo resultado desse exemplo

00:06:59.667 --> 00:07:01.733
usando uma linha de código.

00:07:01.767 --> 00:07:03.767
Isso nos dá
o mesmo resultado.

00:07:03.800 --> 00:07:06.767
Note como ao usarmos o reshape
como método,

00:07:06.800 --> 00:07:10.100
não precisamos passar
o array como argumento.

00:07:10.700 --> 00:07:13.600
De modo semelhante,
também podemos usar reshape

00:07:13.633 --> 00:07:17.367
para criar arrays de rank 2
com a função linspace.

00:07:18.033 --> 00:07:21.400
Por último,
vamos criar arrays NumPy

00:07:21.433 --> 00:07:23.800
que contêm
números aleatórios.

00:07:23.833 --> 00:07:26.067
Com frequência,
em aprendizado de máquina,

00:07:26.100 --> 00:07:28.267
você precisa criar
matrizes aleatórias.

00:07:28.300 --> 00:07:32.133
Por exemplo, ao inicializar
os pesos de uma rede neural,

00:07:32.167 --> 00:07:35.133
NumPy oferece uma variedade
de funções aleatórias

00:07:35.167 --> 00:07:37.400
para nos ajudar a criar
arrays NumPy aleatórios

00:07:37.433 --> 00:07:38.700
de qualquer formato.

00:07:38.733 --> 00:07:41.700
Vamos começar usando
a função random do NumPy

00:07:41.733 --> 00:07:44.200
para criar um array
de um determinado formato

00:07:44.233 --> 00:07:47.400
com floats aleatórios
entre 0 e 1,

00:07:47.433 --> 00:07:51.067
onde 0 é inclusivo
e 1 é exclusivo.

00:07:51.533 --> 00:07:55.133
As funções a seguir,
incluindo essa função random,

00:07:55.167 --> 00:07:58.467
estão contidas
no módulo random do NumPy.

00:07:58.500 --> 00:08:02.433
Então digitamos np.random
para acessar esse módulo

00:08:02.467 --> 00:08:06.567
e depois .random para acessar
a função dentro do módulo.

00:08:06.967 --> 00:08:09.900
NumPy também nos permite criar
arrays NumPy

00:08:09.933 --> 00:08:11.667
que contêm
números inteiros aleatórios

00:08:11.700 --> 00:08:13.933
dentro de um intervalo
determinado.

00:08:13.967 --> 00:08:17.733
Podemos usar a função randint
para fazer isso.

00:08:17.767 --> 00:08:19.933
Isso necessita
três argumentos:

00:08:19.967 --> 00:08:22.167
o limite inferior,
que é inclusivo,

00:08:22.200 --> 00:08:24.367
o limite superior,
que é exclusivo,

00:08:24.400 --> 00:08:26.100
e o formato.

00:08:26.133 --> 00:08:29.567
Em alguns casos,
é preciso criar arrays NumPy

00:08:29.600 --> 00:08:30.900
com números aleatórios

00:08:30.933 --> 00:08:34.100
que satisfaçam
propriedades estatísticas.

00:08:34.133 --> 00:08:37.900
Por exemplo, talvez queira que
os números aleatórios do array

00:08:37.933 --> 00:08:40.000
tenham uma média 0.

00:08:40.033 --> 00:08:42.600
NumPy permite que você crie
arrays aleatórios

00:08:42.633 --> 00:08:46.467
com números tirados de várias
distribuições de probabilidade.

00:08:46.500 --> 00:08:50.200
A função np.random.normal,
por exemplo,

00:08:50.233 --> 00:08:53.000
cria um array
com um formato determinado

00:08:53.033 --> 00:08:54.833
que contém
números aleatórios

00:08:54.867 --> 00:08:57.000
tirados
de uma distribuição normal,

00:08:57.033 --> 00:08:59.833
com uma média dada
e um desvio padrão.

00:08:59.867 --> 00:09:03.433
Isso cria um array
de mil por mil

00:09:03.467 --> 00:09:06.600
de floats aleatórios tirados
de uma distribuição normal

00:09:06.633 --> 00:09:11.167
com uma média 0,
e um desvio padrão de 0.1.

00:09:11.800 --> 00:09:15.967
Como podemos ver, a média
dos números aleatórios do array

00:09:16.000 --> 00:09:18.100
é muito próxima a 0.

00:09:18.133 --> 00:09:22.600
E o desvio padrão
é muito próximo de 0.1.

00:09:22.633 --> 00:09:28.633
O valor máximo e o médio de X
são simétricos em 0, a média.

00:09:28.667 --> 00:09:30.233
E temos quase o mesmo número

00:09:30.267 --> 00:09:32.500
de números inteiros
positivos e negativos.

