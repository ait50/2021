WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.935
正如我们之前说的

00:00:01.935 --> 00:00:06.540
除了逐个访问元素外

00:00:06.540 --> 00:00:11.230
我们还可以用切片操作来访问 NumPy 数组的子集

00:00:11.230 --> 00:00:16.640
要切片 可以在括号里填入索引 并以冒号隔开

00:00:16.640 --> 00:00:20.455
总地来说 有三种切片方法

00:00:20.454 --> 00:00:25.244
第一种 从起始索引开始 到终止索引为止

00:00:25.245 --> 00:00:30.210
第二种 在这里留白 就会从起始索引开始 到数组末端为止

00:00:30.210 --> 00:00:33.490
第三种 在这里留白 就会从数组开头开始

00:00:33.490 --> 00:00:37.164
到终止索引为止

00:00:37.164 --> 00:00:39.119
一般来说 第一种和第三种方法

00:00:39.119 --> 00:00:41.704
终止索引不在访问范围内

00:00:41.704 --> 00:00:45.604
而这里的起始索引是在访问范围内的

00:00:45.604 --> 00:00:48.469
NumPy 数组可以是多维的

00:00:48.469 --> 00:00:54.619
所以在切片时 一般要指定数组各维的切片位置

00:00:54.619 --> 00:00:56.765
我们来看一些切片例子

00:00:56.765 --> 00:00:58.289
以秩为 2 的数组为例

00:00:58.289 --> 00:01:03.354
这个 4 x 5 的数组包含整数 1 到 20

00:01:03.354 --> 00:01:09.450
假设你要从数组里提取这个子集 也就是这九个值

00:01:09.450 --> 00:01:11.924
这是一种切片方法

00:01:11.924 --> 00:01:14.009
逗号前面的部分

00:01:14.010 --> 00:01:18.090
指定了提取目标行的索引

00:01:18.090 --> 00:01:24.034
逗号后面的部分 指定了提取目标列的索引

00:01:24.034 --> 00:01:29.954
记住 起始索引在访问范围内 但终止索引不在

00:01:29.954 --> 00:01:32.965
而索引一般是从 0 开始的

00:01:32.965 --> 00:01:37.329
所以第一行索引为 0 第二行为 1

00:01:37.329 --> 00:01:42.859
因此 这个部分要提取的第 1、2、3 行是这些

00:01:42.859 --> 00:01:48.120
这个部分要提取的第 2、3、4 列是这些

00:01:48.120 --> 00:01:51.505
还有一种切片方法也可以实现同样的效果

00:01:51.504 --> 00:01:55.134
记住 如果冒号后没有终止索引

00:01:55.135 --> 00:01:58.460
切片就默认到最后一个索引为止

00:01:58.459 --> 00:02:02.739
用这些列索引 我们试着提取别的子集

00:02:02.739 --> 00:02:04.824
这次不提取后三行了

00:02:04.825 --> 00:02:06.630
我们要提取前三行

00:02:06.629 --> 00:02:08.590
这行代码提取了这个子集

00:02:08.590 --> 00:02:11.800
记住 不在冒号前写起始索引的话

00:02:11.800 --> 00:02:15.600
切片就默认从数组开头开始

00:02:15.599 --> 00:02:19.784
因而提取出了第 0、1、2 行

00:02:19.784 --> 00:02:21.594
再举一个例子

00:02:21.594 --> 00:02:25.305
我们要选中第三行的所有元素

00:02:25.305 --> 00:02:28.469
如果冒号两边都不填索引的话

00:02:28.469 --> 00:02:31.710
切片就默认提取数组的所有行

00:02:31.710 --> 00:02:33.599
所以 x [ : , 2]

00:02:33.599 --> 00:02:37.664
会提取第二列的所有行

00:02:37.664 --> 00:02:41.104
0、1、2 因此会提取这一列

00:02:41.104 --> 00:02:44.759
如果我们想选中第三列的所有元素

00:02:44.759 --> 00:02:49.419
但将其返回成一个秩为 2 的数组 我们可以这么做

00:02:49.419 --> 00:02:55.064
注意 当我们这么选出第三列的所有元素时

00:02:55.064 --> 00:03:00.810
切片返回了一个秩为 1 的数组 而非秩为 2 的数组

00:03:00.810 --> 00:03:03.030
如果像这样对 X 进行切片

00:03:03.030 --> 00:03:04.569
虽然只改变了一点

00:03:04.569 --> 00:03:07.799
但我们就得到了一个秩为 2 的 NumPy 数组

00:03:07.800 --> 00:03:10.670
注意 在对 NumPy 数组进行切片

00:03:10.669 --> 00:03:13.994
并将其保存到新变量中时

00:03:13.995 --> 00:03:19.490
就像这里 实际上数据并没有复制到新变量中

00:03:19.490 --> 00:03:23.555
这一点总是让新手很困惑

00:03:23.555 --> 00:03:26.180
所以我们来具体讲讲

00:03:26.180 --> 00:03:30.650
在这些例子中 原数组 X 的切片

00:03:30.650 --> 00:03:33.750
并没有复制到变量 z 中

00:03:33.750 --> 00:03:39.115
相反 X 和 z 只是同一个数组的两个不同名称

00:03:39.115 --> 00:03:43.950
我们说 切片是原数组的新视角

00:03:43.949 --> 00:03:47.144
也就是说 你对 z 做出的任何修改

00:03:47.145 --> 00:03:50.270
都会改变 X 里的元素

00:03:50.270 --> 00:03:53.725
以那个 4 x 5 数组为例

00:03:53.724 --> 00:03:56.719
我们再选中这里的元素

00:03:56.719 --> 00:03:59.224
并将其赋给变量 z

00:03:59.224 --> 00:04:04.555
现在 把 z 的最后一个元素改为 555

00:04:04.555 --> 00:04:06.605
此时如果输出 X

00:04:06.604 --> 00:04:10.364
我们会发现 X 也有同样的改动

00:04:10.365 --> 00:04:16.100
要新建 NumPy 数组来存放切片值副本

00:04:16.100 --> 00:04:18.870
就用 NumPy 的函数 copy

00:04:18.870 --> 00:04:21.735
这个函数也可以当方法用

00:04:21.735 --> 00:04:24.504
就像之前的函数 reshape 一样

00:04:24.504 --> 00:04:27.935
还是用这个例子 我们来看看 copy 命令

00:04:27.935 --> 00:04:33.990
还是这个数组 X 我们用函数 copy 来为这个切片创建一个副本

00:04:33.990 --> 00:04:37.435
我们还可以像这样把 copy 当方法用

00:04:37.435 --> 00:04:41.944
再把 z 的最后一个元素改为 555

00:04:41.944 --> 00:04:45.144
这次 X 就没有变化了

00:04:45.144 --> 00:04:47.125
使用 copy 命令

00:04:47.125 --> 00:04:49.490
我们就可以新建

00:04:49.490 --> 00:04:52.324
完全独立于原数组的NumPy 数组了

00:04:52.324 --> 00:04:57.084
把数组当索引用

00:04:57.084 --> 00:05:00.889
就能很方便地对别的 NumPy 数组进行切片、选择及元素更改等操作了

00:05:00.889 --> 00:05:02.709
来看些例子

00:05:02.709 --> 00:05:09.300
我们来创建一个秩为 1 的数组 以其为索引 对 X 的元素进行选择

00:05:09.300 --> 00:05:15.754
我们可以用这个 NumPy 索引数组来选择 X 的第二和第四行

00:05:15.754 --> 00:05:21.379
也可以用这个数组来选择 X 的第二和第四列

00:05:21.379 --> 00:05:27.975
NumPy 还提供了一些内置函数 用于选择 NumPy 数组里的特定元素

00:05:27.975 --> 00:05:35.135
比如 NumPy 的函数 diag 可以提取数组对角线上的元素

00:05:35.134 --> 00:05:38.545
记住 X 是这个

00:05:38.545 --> 00:05:45.185
我们还可以输出在 X 主对角线上方的元素

00:05:45.185 --> 00:05:47.204
只需将参数 k 设为 1 即可

00:05:47.204 --> 00:05:51.954
这样 diag 就会提取元素 1、7、13 和 19 了

00:05:51.954 --> 00:05:54.269
如果 k 为负值

00:05:54.269 --> 00:05:59.474
那 diag 就会提取主对角线下方的数值 即 5、11 和 17

00:05:59.475 --> 00:06:01.895
k 默认为 0

00:06:01.894 --> 00:06:04.509
因此默认提取的是主对角线上的元素

00:06:04.509 --> 00:06:10.069
仅提取 NumPy 数组里独一无二的元素也是常用操作

00:06:10.069 --> 00:06:15.915
我们可以用 NumPy 函数 unique 来找出数组独一无二的元素

00:06:15.915 --> 00:06:19.970
这个 3 x 3 数组里有重复的值

00:06:19.970 --> 00:06:23.730
我们可以像这样找出数组里独一无二的值

